(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
}((function () { 'use strict';

	var empty = {};

	var empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': empty
	});

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	var encode_1 = encode$2;

	var MSB$1 = 0x80
	  , REST$1 = 0x7F
	  , MSBALL = ~REST$1
	  , INT = Math.pow(2, 31);

	function encode$2(num, out, offset) {
	  out = out || [];
	  offset = offset || 0;
	  var oldOffset = offset;

	  while(num >= INT) {
	    out[offset++] = (num & 0xFF) | MSB$1;
	    num /= 128;
	  }
	  while(num & MSBALL) {
	    out[offset++] = (num & 0xFF) | MSB$1;
	    num >>>= 7;
	  }
	  out[offset] = num | 0;
	  
	  encode$2.bytes = offset - oldOffset + 1;
	  
	  return out
	}

	var decode$2 = read$1;

	var MSB = 0x80
	  , REST = 0x7F;

	function read$1(buf, offset) {
	  var res    = 0
	    , offset = offset || 0
	    , shift  = 0
	    , counter = offset
	    , b
	    , l = buf.length;

	  do {
	    if (counter >= l) {
	      read$1.bytes = 0;
	      throw new RangeError('Could not decode varint')
	    }
	    b = buf[counter++];
	    res += shift < 28
	      ? (b & REST) << shift
	      : (b & REST) * Math.pow(2, shift);
	    shift += 7;
	  } while (b >= MSB)

	  read$1.bytes = counter - offset;

	  return res
	}

	var N1 = Math.pow(2,  7);
	var N2 = Math.pow(2, 14);
	var N3 = Math.pow(2, 21);
	var N4 = Math.pow(2, 28);
	var N5 = Math.pow(2, 35);
	var N6 = Math.pow(2, 42);
	var N7 = Math.pow(2, 49);
	var N8 = Math.pow(2, 56);
	var N9 = Math.pow(2, 63);

	var length = function (value) {
	  return (
	    value < N1 ? 1
	  : value < N2 ? 2
	  : value < N3 ? 3
	  : value < N4 ? 4
	  : value < N5 ? 5
	  : value < N6 ? 6
	  : value < N7 ? 7
	  : value < N8 ? 8
	  : value < N9 ? 9
	  :              10
	  )
	};

	var varint = {
	    encode: encode_1
	  , decode: decode$2
	  , encodingLength: length
	};

	var identity$1 = 0;
	var ip4$1 = 4;
	var tcp$1 = 6;
	var sha1$1 = 17;
	var dccp$1 = 33;
	var ip6$1 = 41;
	var ip6zone$1 = 42;
	var path$1 = 47;
	var multicodec$1 = 48;
	var multihash$1 = 49;
	var multiaddr$1 = 50;
	var multibase$1 = 51;
	var dns$1 = 53;
	var dns4$1 = 54;
	var dns6$1 = 55;
	var dnsaddr$1 = 56;
	var protobuf$1 = 80;
	var cbor$1 = 81;
	var raw$1 = 85;
	var rlp$1 = 96;
	var bencode$1 = 99;
	var sctp$1 = 132;
	var md4$1 = 212;
	var md5$1 = 213;
	var bmt$1 = 214;
	var zeronet$1 = 230;
	var udp$1 = 273;
	var udt$1 = 301;
	var utp$1 = 302;
	var unix$1 = 400;
	var p2p$1 = 421;
	var ipfs$1 = 421;
	var https$1 = 443;
	var onion$1 = 444;
	var onion3$1 = 445;
	var garlic64$1 = 446;
	var garlic32$1 = 447;
	var tls$1 = 448;
	var quic$1 = 460;
	var ws$1 = 477;
	var wss$1 = 478;
	var http$1 = 480;
	var json$1 = 512;
	var messagepack$1 = 513;
	var x11$1 = 4352;
	var table = {
		identity: identity$1,
		ip4: ip4$1,
		tcp: tcp$1,
		sha1: sha1$1,
		"sha2-256": 18,
		"sha2-512": 19,
		"sha3-512": 20,
		"sha3-384": 21,
		"sha3-256": 22,
		"sha3-224": 23,
		"shake-128": 24,
		"shake-256": 25,
		"keccak-224": 26,
		"keccak-256": 27,
		"keccak-384": 28,
		"keccak-512": 29,
		dccp: dccp$1,
		"murmur3-128": 34,
		"murmur3-32": 35,
		ip6: ip6$1,
		ip6zone: ip6zone$1,
		path: path$1,
		multicodec: multicodec$1,
		multihash: multihash$1,
		multiaddr: multiaddr$1,
		multibase: multibase$1,
		dns: dns$1,
		dns4: dns4$1,
		dns6: dns6$1,
		dnsaddr: dnsaddr$1,
		protobuf: protobuf$1,
		cbor: cbor$1,
		raw: raw$1,
		"dbl-sha2-256": 86,
		rlp: rlp$1,
		bencode: bencode$1,
		"dag-pb": 112,
		"dag-cbor": 113,
		"libp2p-key": 114,
		"git-raw": 120,
		"torrent-info": 123,
		"torrent-file": 124,
		"leofcoin-block": 129,
		"leofcoin-tx": 130,
		"leofcoin-pr": 131,
		sctp: sctp$1,
		"eth-block": 144,
		"eth-block-list": 145,
		"eth-tx-trie": 146,
		"eth-tx": 147,
		"eth-tx-receipt-trie": 148,
		"eth-tx-receipt": 149,
		"eth-state-trie": 150,
		"eth-account-snapshot": 151,
		"eth-storage-trie": 152,
		"bitcoin-block": 176,
		"bitcoin-tx": 177,
		"zcash-block": 192,
		"zcash-tx": 193,
		"stellar-block": 208,
		"stellar-tx": 209,
		md4: md4$1,
		md5: md5$1,
		bmt: bmt$1,
		"decred-block": 224,
		"decred-tx": 225,
		"ipld-ns": 226,
		"ipfs-ns": 227,
		"swarm-ns": 228,
		"ipns-ns": 229,
		zeronet: zeronet$1,
		"ed25519-pub": 237,
		"dash-block": 240,
		"dash-tx": 241,
		"swarm-manifest": 250,
		"swarm-feed": 251,
		udp: udp$1,
		"p2p-webrtc-star": 275,
		"p2p-webrtc-direct": 276,
		"p2p-stardust": 277,
		"p2p-circuit": 290,
		"dag-json": 297,
		udt: udt$1,
		utp: utp$1,
		unix: unix$1,
		p2p: p2p$1,
		ipfs: ipfs$1,
		https: https$1,
		onion: onion$1,
		onion3: onion3$1,
		garlic64: garlic64$1,
		garlic32: garlic32$1,
		tls: tls$1,
		quic: quic$1,
		ws: ws$1,
		wss: wss$1,
		"p2p-websocket-star": 479,
		http: http$1,
		json: json$1,
		messagepack: messagepack$1,
		x11: x11$1,
		"blake2b-8": 45569,
		"blake2b-16": 45570,
		"blake2b-24": 45571,
		"blake2b-32": 45572,
		"blake2b-40": 45573,
		"blake2b-48": 45574,
		"blake2b-56": 45575,
		"blake2b-64": 45576,
		"blake2b-72": 45577,
		"blake2b-80": 45578,
		"blake2b-88": 45579,
		"blake2b-96": 45580,
		"blake2b-104": 45581,
		"blake2b-112": 45582,
		"blake2b-120": 45583,
		"blake2b-128": 45584,
		"blake2b-136": 45585,
		"blake2b-144": 45586,
		"blake2b-152": 45587,
		"blake2b-160": 45588,
		"blake2b-168": 45589,
		"blake2b-176": 45590,
		"blake2b-184": 45591,
		"blake2b-192": 45592,
		"blake2b-200": 45593,
		"blake2b-208": 45594,
		"blake2b-216": 45595,
		"blake2b-224": 45596,
		"blake2b-232": 45597,
		"blake2b-240": 45598,
		"blake2b-248": 45599,
		"blake2b-256": 45600,
		"blake2b-264": 45601,
		"blake2b-272": 45602,
		"blake2b-280": 45603,
		"blake2b-288": 45604,
		"blake2b-296": 45605,
		"blake2b-304": 45606,
		"blake2b-312": 45607,
		"blake2b-320": 45608,
		"blake2b-328": 45609,
		"blake2b-336": 45610,
		"blake2b-344": 45611,
		"blake2b-352": 45612,
		"blake2b-360": 45613,
		"blake2b-368": 45614,
		"blake2b-376": 45615,
		"blake2b-384": 45616,
		"blake2b-392": 45617,
		"blake2b-400": 45618,
		"blake2b-408": 45619,
		"blake2b-416": 45620,
		"blake2b-424": 45621,
		"blake2b-432": 45622,
		"blake2b-440": 45623,
		"blake2b-448": 45624,
		"blake2b-456": 45625,
		"blake2b-464": 45626,
		"blake2b-472": 45627,
		"blake2b-480": 45628,
		"blake2b-488": 45629,
		"blake2b-496": 45630,
		"blake2b-504": 45631,
		"blake2b-512": 45632,
		"blake2s-8": 45633,
		"blake2s-16": 45634,
		"blake2s-24": 45635,
		"blake2s-32": 45636,
		"blake2s-40": 45637,
		"blake2s-48": 45638,
		"blake2s-56": 45639,
		"blake2s-64": 45640,
		"blake2s-72": 45641,
		"blake2s-80": 45642,
		"blake2s-88": 45643,
		"blake2s-96": 45644,
		"blake2s-104": 45645,
		"blake2s-112": 45646,
		"blake2s-120": 45647,
		"blake2s-128": 45648,
		"blake2s-136": 45649,
		"blake2s-144": 45650,
		"blake2s-152": 45651,
		"blake2s-160": 45652,
		"blake2s-168": 45653,
		"blake2s-176": 45654,
		"blake2s-184": 45655,
		"blake2s-192": 45656,
		"blake2s-200": 45657,
		"blake2s-208": 45658,
		"blake2s-216": 45659,
		"blake2s-224": 45660,
		"blake2s-232": 45661,
		"blake2s-240": 45662,
		"blake2s-248": 45663,
		"blake2s-256": 45664,
		"skein256-8": 45825,
		"skein256-16": 45826,
		"skein256-24": 45827,
		"skein256-32": 45828,
		"skein256-40": 45829,
		"skein256-48": 45830,
		"skein256-56": 45831,
		"skein256-64": 45832,
		"skein256-72": 45833,
		"skein256-80": 45834,
		"skein256-88": 45835,
		"skein256-96": 45836,
		"skein256-104": 45837,
		"skein256-112": 45838,
		"skein256-120": 45839,
		"skein256-128": 45840,
		"skein256-136": 45841,
		"skein256-144": 45842,
		"skein256-152": 45843,
		"skein256-160": 45844,
		"skein256-168": 45845,
		"skein256-176": 45846,
		"skein256-184": 45847,
		"skein256-192": 45848,
		"skein256-200": 45849,
		"skein256-208": 45850,
		"skein256-216": 45851,
		"skein256-224": 45852,
		"skein256-232": 45853,
		"skein256-240": 45854,
		"skein256-248": 45855,
		"skein256-256": 45856,
		"skein512-8": 45857,
		"skein512-16": 45858,
		"skein512-24": 45859,
		"skein512-32": 45860,
		"skein512-40": 45861,
		"skein512-48": 45862,
		"skein512-56": 45863,
		"skein512-64": 45864,
		"skein512-72": 45865,
		"skein512-80": 45866,
		"skein512-88": 45867,
		"skein512-96": 45868,
		"skein512-104": 45869,
		"skein512-112": 45870,
		"skein512-120": 45871,
		"skein512-128": 45872,
		"skein512-136": 45873,
		"skein512-144": 45874,
		"skein512-152": 45875,
		"skein512-160": 45876,
		"skein512-168": 45877,
		"skein512-176": 45878,
		"skein512-184": 45879,
		"skein512-192": 45880,
		"skein512-200": 45881,
		"skein512-208": 45882,
		"skein512-216": 45883,
		"skein512-224": 45884,
		"skein512-232": 45885,
		"skein512-240": 45886,
		"skein512-248": 45887,
		"skein512-256": 45888,
		"skein512-264": 45889,
		"skein512-272": 45890,
		"skein512-280": 45891,
		"skein512-288": 45892,
		"skein512-296": 45893,
		"skein512-304": 45894,
		"skein512-312": 45895,
		"skein512-320": 45896,
		"skein512-328": 45897,
		"skein512-336": 45898,
		"skein512-344": 45899,
		"skein512-352": 45900,
		"skein512-360": 45901,
		"skein512-368": 45902,
		"skein512-376": 45903,
		"skein512-384": 45904,
		"skein512-392": 45905,
		"skein512-400": 45906,
		"skein512-408": 45907,
		"skein512-416": 45908,
		"skein512-424": 45909,
		"skein512-432": 45910,
		"skein512-440": 45911,
		"skein512-448": 45912,
		"skein512-456": 45913,
		"skein512-464": 45914,
		"skein512-472": 45915,
		"skein512-480": 45916,
		"skein512-488": 45917,
		"skein512-496": 45918,
		"skein512-504": 45919,
		"skein512-512": 45920,
		"skein1024-8": 45921,
		"skein1024-16": 45922,
		"skein1024-24": 45923,
		"skein1024-32": 45924,
		"skein1024-40": 45925,
		"skein1024-48": 45926,
		"skein1024-56": 45927,
		"skein1024-64": 45928,
		"skein1024-72": 45929,
		"skein1024-80": 45930,
		"skein1024-88": 45931,
		"skein1024-96": 45932,
		"skein1024-104": 45933,
		"skein1024-112": 45934,
		"skein1024-120": 45935,
		"skein1024-128": 45936,
		"skein1024-136": 45937,
		"skein1024-144": 45938,
		"skein1024-152": 45939,
		"skein1024-160": 45940,
		"skein1024-168": 45941,
		"skein1024-176": 45942,
		"skein1024-184": 45943,
		"skein1024-192": 45944,
		"skein1024-200": 45945,
		"skein1024-208": 45946,
		"skein1024-216": 45947,
		"skein1024-224": 45948,
		"skein1024-232": 45949,
		"skein1024-240": 45950,
		"skein1024-248": 45951,
		"skein1024-256": 45952,
		"skein1024-264": 45953,
		"skein1024-272": 45954,
		"skein1024-280": 45955,
		"skein1024-288": 45956,
		"skein1024-296": 45957,
		"skein1024-304": 45958,
		"skein1024-312": 45959,
		"skein1024-320": 45960,
		"skein1024-328": 45961,
		"skein1024-336": 45962,
		"skein1024-344": 45963,
		"skein1024-352": 45964,
		"skein1024-360": 45965,
		"skein1024-368": 45966,
		"skein1024-376": 45967,
		"skein1024-384": 45968,
		"skein1024-392": 45969,
		"skein1024-400": 45970,
		"skein1024-408": 45971,
		"skein1024-416": 45972,
		"skein1024-424": 45973,
		"skein1024-432": 45974,
		"skein1024-440": 45975,
		"skein1024-448": 45976,
		"skein1024-456": 45977,
		"skein1024-464": 45978,
		"skein1024-472": 45979,
		"skein1024-480": 45980,
		"skein1024-488": 45981,
		"skein1024-496": 45982,
		"skein1024-504": 45983,
		"skein1024-512": 45984,
		"skein1024-520": 45985,
		"skein1024-528": 45986,
		"skein1024-536": 45987,
		"skein1024-544": 45988,
		"skein1024-552": 45989,
		"skein1024-560": 45990,
		"skein1024-568": 45991,
		"skein1024-576": 45992,
		"skein1024-584": 45993,
		"skein1024-592": 45994,
		"skein1024-600": 45995,
		"skein1024-608": 45996,
		"skein1024-616": 45997,
		"skein1024-624": 45998,
		"skein1024-632": 45999,
		"skein1024-640": 46000,
		"skein1024-648": 46001,
		"skein1024-656": 46002,
		"skein1024-664": 46003,
		"skein1024-672": 46004,
		"skein1024-680": 46005,
		"skein1024-688": 46006,
		"skein1024-696": 46007,
		"skein1024-704": 46008,
		"skein1024-712": 46009,
		"skein1024-720": 46010,
		"skein1024-728": 46011,
		"skein1024-736": 46012,
		"skein1024-744": 46013,
		"skein1024-752": 46014,
		"skein1024-760": 46015,
		"skein1024-768": 46016,
		"skein1024-776": 46017,
		"skein1024-784": 46018,
		"skein1024-792": 46019,
		"skein1024-800": 46020,
		"skein1024-808": 46021,
		"skein1024-816": 46022,
		"skein1024-824": 46023,
		"skein1024-832": 46024,
		"skein1024-840": 46025,
		"skein1024-848": 46026,
		"skein1024-856": 46027,
		"skein1024-864": 46028,
		"skein1024-872": 46029,
		"skein1024-880": 46030,
		"skein1024-888": 46031,
		"skein1024-896": 46032,
		"skein1024-904": 46033,
		"skein1024-912": 46034,
		"skein1024-920": 46035,
		"skein1024-928": 46036,
		"skein1024-936": 46037,
		"skein1024-944": 46038,
		"skein1024-952": 46039,
		"skein1024-960": 46040,
		"skein1024-968": 46041,
		"skein1024-976": 46042,
		"skein1024-984": 46043,
		"skein1024-992": 46044,
		"skein1024-1000": 46045,
		"skein1024-1008": 46046,
		"skein1024-1016": 46047,
		"skein1024-1024": 46048,
		"holochain-adr-v0": 8417572,
		"holochain-adr-v1": 8483108,
		"holochain-key-v0": 9728292,
		"holochain-key-v1": 9793828,
		"holochain-sig-v0": 10645796,
		"holochain-sig-v1": 10711332
	};

	// map for hexString -> codecName
	const nameTable$1 = new Map();

	for (const encodingName in table) {
	  const code = table[encodingName];
	  nameTable$1.set(code, encodingName);
	}

	var intTable$1 = Object.freeze(nameTable$1);

	var util$1 = {
	  numberToBuffer: numberToBuffer$1,
	  bufferToNumber: bufferToNumber$1,
	  varintBufferEncode: varintBufferEncode$1,
	  varintBufferDecode: varintBufferDecode$1,
	  varintEncode: varintEncode$3
	};

	function bufferToNumber$1 (buf) {
	  return parseInt(buf.toString('hex'), 16)
	}

	function numberToBuffer$1 (num) {
	  let hexString = num.toString(16);
	  if (hexString.length % 2 === 1) {
	    hexString = '0' + hexString;
	  }
	  return Buffer.from(hexString, 'hex')
	}

	function varintBufferEncode$1 (input) {
	  return Buffer.from(varint.encode(bufferToNumber$1(input)))
	}

	function varintBufferDecode$1 (input) {
	  return numberToBuffer$1(varint.decode(input))
	}

	function varintEncode$3 (num) {
	  return Buffer.from(varint.encode(num))
	}

	const varintEncode$2 = util$1.varintEncode;

	// map for codecName -> codeVarintBuffer
	const varintTable$1 = {};

	for (const encodingName in table) {
	  const code = table[encodingName];
	  varintTable$1[encodingName] = varintEncode$2(code);
	}

	var varintTable_1$1 = Object.freeze(varintTable$1);

	// map for codecConstant -> code
	const constants$4 = {};

	for (const [name, code] of Object.entries(table)) {
	  constants$4[name.toUpperCase().replace(/-/g, '_')] = code;
	}

	var constants_1$3 = Object.freeze(constants$4);

	// map for code -> print friendly name
	const tableByCode$1 = {};

	for (const [name, code] of Object.entries(table)) {
	  if (tableByCode$1[code] === undefined) tableByCode$1[code] = name;
	}

	var print$1 = Object.freeze(tableByCode$1);

	/**
	 * Implementation of the multicodec specification.
	 *
	 * @module multicodec
	 * @example
	 * const multicodec = require('multicodec')
	 *
	 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
	 * // prefixedProtobuf 0x50...
	 *
	 */

	var src$7 = createCommonjsModule(function (module, exports) {






	exports = module.exports;

	/**
	 * Prefix a buffer with a multicodec-packed.
	 *
	 * @param {string|number} multicodecStrOrCode
	 * @param {Buffer} data
	 * @returns {Buffer}
	 */
	exports.addPrefix = (multicodecStrOrCode, data) => {
	  let prefix;

	  if (Buffer.isBuffer(multicodecStrOrCode)) {
	    prefix = util$1.varintBufferEncode(multicodecStrOrCode);
	  } else {
	    if (varintTable_1$1[multicodecStrOrCode]) {
	      prefix = varintTable_1$1[multicodecStrOrCode];
	    } else {
	      throw new Error('multicodec not recognized')
	    }
	  }
	  return Buffer.concat([prefix, data])
	};

	/**
	 * Decapsulate the multicodec-packed prefix from the data.
	 *
	 * @param {Buffer} data
	 * @returns {Buffer}
	 */
	exports.rmPrefix = (data) => {
	  varint.decode(data);
	  return data.slice(varint.decode.bytes)
	};

	/**
	 * Get the codec of the prefixed data.
	 * @param {Buffer} prefixedData
	 * @returns {string}
	 */
	exports.getCodec = (prefixedData) => {
	  const code = varint.decode(prefixedData);
	  const codecName = intTable$1.get(code);
	  if (codecName === undefined) {
	    throw new Error(`Code ${code} not found`)
	  }
	  return codecName
	};

	/**
	 * Get the name of the codec.
	 * @param {number} codec
	 * @returns {string}
	 */
	exports.getName = (codec) => {
	  return intTable$1.get(codec)
	};

	/**
	 * Get the code of the codec
	 * @param {string} name
	 * @returns {number}
	 */
	exports.getNumber = (name) => {
	  const code = varintTable_1$1[name];
	  if (code === undefined) {
	    throw new Error('Codec `' + name + '` not found')
	  }
	  return util$1.varintBufferDecode(code)[0]
	};

	/**
	 * Get the code of the prefixed data.
	 * @param {Buffer} prefixedData
	 * @returns {number}
	 */
	exports.getCode = (prefixedData) => {
	  return varint.decode(prefixedData)
	};

	/**
	 * Get the code as varint of a codec name.
	 * @param {string} codecName
	 * @returns {Buffer}
	 */
	exports.getCodeVarint = (codecName) => {
	  const code = varintTable_1$1[codecName];
	  if (code === undefined) {
	    throw new Error('Codec `' + codecName + '` not found')
	  }
	  return code
	};

	/**
	 * Get the varint of a code.
	 * @param {Number} code
	 * @returns {Array.<number>}
	 */
	exports.getVarint = (code) => {
	  return varint.encode(code)
	};

	// Make the constants top-level constants

	Object.assign(exports, constants_1$3);

	// Human friendly names for printing, e.g. in error messages
	exports.print = print$1;
	});

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString = {}.toString;

	var isArray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$8.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	var _kMaxLength = kMaxLength();

	function kMaxLength () {
	  return Buffer$8.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$8.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$8(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$8 (arg, encodingOrOffset, length) {
	  if (!Buffer$8.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$8)) {
	    return new Buffer$8(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$8.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$8._augment = function (arr) {
	  arr.__proto__ = Buffer$8.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$8.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	  Buffer$8.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$8.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$8.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$8.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$8.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$8.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$8.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$8.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0;
	  }
	  return Buffer$8.alloc(+length)
	}
	Buffer$8.isBuffer = isBuffer;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$8.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$8.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$8.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$8.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$8.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$8.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$8.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$8.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$8.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$8.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$8.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$8.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$8.compare(this, b) === 0
	};

	Buffer$8.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$8.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$8.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$8.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$8.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$8.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$8.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$8.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$8.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$8.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$8.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$8(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$8.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$8.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$8.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$8.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$8.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$8.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$8.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$8.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$8.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$8.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$8.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$8.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$8.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$8.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$8.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$8.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$8.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$8.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$8.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$8.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$8.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$8.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$8.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$8.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$8.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$8.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$8.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$8.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$8.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$8.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$8.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$8.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$8.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$8.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$8.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$8.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$8.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$8.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$8.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$8.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$8.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$8(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var bufferEs6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
		kMaxLength: _kMaxLength,
		Buffer: Buffer$8,
		SlowBuffer: SlowBuffer,
		isBuffer: isBuffer
	});

	class Base$1 {
	  constructor (name, code, implementation, alphabet) {
	    this.name = name;
	    this.code = code;
	    this.alphabet = alphabet;
	    if (implementation && alphabet) {
	      this.engine = implementation(alphabet);
	    }
	  }

	  encode (stringOrBuffer) {
	    return this.engine.encode(stringOrBuffer)
	  }

	  decode (stringOrBuffer) {
	    return this.engine.decode(stringOrBuffer)
	  }

	  isImplemented () {
	    return this.engine
	  }
	}

	var base$2 = Base$1;

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(bufferEs6);

	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

	var safeBuffer = createCommonjsModule(function (module, exports) {
	/* eslint-disable node/no-deprecated-api */

	var Buffer = require$$0.Buffer;

	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key];
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = require$$0;
	} else {
	  // Copy properties from require('buffer')
	  copyProps(require$$0, exports);
	  exports.Buffer = SafeBuffer;
	}

	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}

	SafeBuffer.prototype = Object.create(Buffer.prototype);

	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer);

	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	};

	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size);
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	  } else {
	    buf.fill(0);
	  }
	  return buf
	};

	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	};

	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return require$$0.SlowBuffer(size)
	};
	});

	// base-x encoding / decoding
	// Copyright (c) 2018 base-x contributors
	// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
	// Distributed under the MIT software license, see the accompanying
	// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
	// @ts-ignore
	var _Buffer = safeBuffer.Buffer;
	function base$1 (ALPHABET) {
	  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
	  var BASE_MAP = new Uint8Array(256);
	  for (var j = 0; j < BASE_MAP.length; j++) {
	    BASE_MAP[j] = 255;
	  }
	  for (var i = 0; i < ALPHABET.length; i++) {
	    var x = ALPHABET.charAt(i);
	    var xc = x.charCodeAt(0);
	    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
	    BASE_MAP[xc] = i;
	  }
	  var BASE = ALPHABET.length;
	  var LEADER = ALPHABET.charAt(0);
	  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
	  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
	  function encode (source) {
	    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
	    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
	    if (source.length === 0) { return '' }
	        // Skip & count leading zeroes.
	    var zeroes = 0;
	    var length = 0;
	    var pbegin = 0;
	    var pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	      pbegin++;
	      zeroes++;
	    }
	        // Allocate enough space in big-endian base58 representation.
	    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    var b58 = new Uint8Array(size);
	        // Process the bytes.
	    while (pbegin !== pend) {
	      var carry = source[pbegin];
	            // Apply "b58 = b58 * 256 + ch".
	      var i = 0;
	      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
	        carry += (256 * b58[it1]) >>> 0;
	        b58[it1] = (carry % BASE) >>> 0;
	        carry = (carry / BASE) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      pbegin++;
	    }
	        // Skip leading zeroes in base58 result.
	    var it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	      it2++;
	    }
	        // Translate the result into a string.
	    var str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
	    return str
	  }
	  function decodeUnsafe (source) {
	    if (typeof source !== 'string') { throw new TypeError('Expected String') }
	    if (source.length === 0) { return _Buffer.alloc(0) }
	    var psz = 0;
	        // Skip leading spaces.
	    if (source[psz] === ' ') { return }
	        // Skip and count leading '1's.
	    var zeroes = 0;
	    var length = 0;
	    while (source[psz] === LEADER) {
	      zeroes++;
	      psz++;
	    }
	        // Allocate enough space in big-endian base256 representation.
	    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
	    var b256 = new Uint8Array(size);
	        // Process the characters.
	    while (source[psz]) {
	            // Decode character
	      var carry = BASE_MAP[source.charCodeAt(psz)];
	            // Invalid character
	      if (carry === 255) { return }
	      var i = 0;
	      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
	        carry += (BASE * b256[it3]) >>> 0;
	        b256[it3] = (carry % 256) >>> 0;
	        carry = (carry / 256) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      psz++;
	    }
	        // Skip trailing spaces.
	    if (source[psz] === ' ') { return }
	        // Skip leading zeroes in b256.
	    var it4 = size - length;
	    while (it4 !== size && b256[it4] === 0) {
	      it4++;
	    }
	    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
	    vch.fill(0x00, 0, zeroes);
	    var j = zeroes;
	    while (it4 !== size) {
	      vch[j++] = b256[it4++];
	    }
	    return vch
	  }
	  function decode (string) {
	    var buffer = decodeUnsafe(string);
	    if (buffer) { return buffer }
	    throw new Error('Non-base' + BASE + ' character')
	  }
	  return {
	    encode: encode,
	    decodeUnsafe: decodeUnsafe,
	    decode: decode
	  }
	}
	var src$6 = base$1;

	const { Buffer: Buffer$7 } = require$$0;

	var base16$1 = function base16 (alphabet) {
	  return {
	    encode (input) {
	      if (typeof input === 'string') {
	        return Buffer$7.from(input).toString('hex')
	      }
	      return input.toString('hex')
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base16 character')
	        }
	      }
	      return Buffer$7.from(input, 'hex')
	    }
	  }
	};

	function decode$1 (input, alphabet) {
	  input = input.replace(new RegExp('=', 'g'), '');
	  const length = input.length;

	  let bits = 0;
	  let value = 0;

	  let index = 0;
	  const output = new Uint8Array((length * 5 / 8) | 0);

	  for (let i = 0; i < length; i++) {
	    value = (value << 5) | alphabet.indexOf(input[i]);
	    bits += 5;

	    if (bits >= 8) {
	      output[index++] = (value >>> (bits - 8)) & 255;
	      bits -= 8;
	    }
	  }

	  return output.buffer
	}

	function encode$1 (buffer, alphabet) {
	  const length = buffer.byteLength;
	  const view = new Uint8Array(buffer);
	  const padding = alphabet.indexOf('=') === alphabet.length - 1;

	  if (padding) {
	    alphabet = alphabet.substring(0, alphabet.length - 1);
	  }

	  let bits = 0;
	  let value = 0;
	  let output = '';

	  for (let i = 0; i < length; i++) {
	    value = (value << 8) | view[i];
	    bits += 8;

	    while (bits >= 5) {
	      output += alphabet[(value >>> (bits - 5)) & 31];
	      bits -= 5;
	    }
	  }

	  if (bits > 0) {
	    output += alphabet[(value << (5 - bits)) & 31];
	  }

	  if (padding) {
	    while ((output.length % 8) !== 0) {
	      output += '=';
	    }
	  }

	  return output
	}

	var base32$1 = function base32 (alphabet) {
	  return {
	    encode (input) {
	      if (typeof input === 'string') {
	        return encode$1(Uint8Array.from(input), alphabet)
	      }

	      return encode$1(input, alphabet)
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base32 character')
	        }
	      }

	      return decode$1(input, alphabet)
	    }
	  }
	};

	const { Buffer: Buffer$6 } = require$$0;

	var base64$1 = function base64 (alphabet) {
	  // The alphabet is only used to know:
	  //   1. If padding is enabled (must contain '=')
	  //   2. If the output must be url-safe (must contain '-' and '_')
	  //   3. If the input of the output function is valid
	  // The alphabets from RFC 4648 are always used.
	  const padding = alphabet.indexOf('=') > -1;
	  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1;

	  return {
	    encode (input) {
	      let output = '';

	      if (typeof input === 'string') {
	        output = Buffer$6.from(input).toString('base64');
	      } else {
	        output = input.toString('base64');
	      }

	      if (url) {
	        output = output.replace(/\+/g, '-').replace(/\//g, '_');
	      }

	      const pad = output.indexOf('=');
	      if (pad > 0 && !padding) {
	        output = output.substring(0, pad);
	      }

	      return output
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base64 character')
	        }
	      }

	      return Buffer$6.from(input, 'base64')
	    }
	  }
	};

	// name, code, implementation, alphabet
	const constants$3 = [
	  ['base1', '1', '', '1'],
	  ['base2', '0', src$6, '01'],
	  ['base8', '7', src$6, '01234567'],
	  ['base10', '9', src$6, '0123456789'],
	  ['base16', 'f', base16$1, '0123456789abcdef'],
	  ['base32', 'b', base32$1, 'abcdefghijklmnopqrstuvwxyz234567'],
	  ['base32pad', 'c', base32$1, 'abcdefghijklmnopqrstuvwxyz234567='],
	  ['base32hex', 'v', base32$1, '0123456789abcdefghijklmnopqrstuv'],
	  ['base32hexpad', 't', base32$1, '0123456789abcdefghijklmnopqrstuv='],
	  ['base32z', 'h', base32$1, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
	  ['base58flickr', 'Z', src$6, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
	  ['base58btc', 'z', src$6, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
	  ['base64', 'm', base64$1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
	  ['base64pad', 'M', base64$1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
	  ['base64url', 'u', base64$1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
	  ['base64urlpad', 'U', base64$1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
	];

	const names$2 = constants$3.reduce((prev, tupple) => {
	  prev[tupple[0]] = new base$2(tupple[0], tupple[1], tupple[2], tupple[3]);
	  return prev
	}, {});

	const codes$2 = constants$3.reduce((prev, tupple) => {
	  prev[tupple[1]] = names$2[tupple[0]];
	  return prev
	}, {});

	var constants_1$2 = {
	  names: names$2,
	  codes: codes$2
	};

	/**
	 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
	 * @module Multibase
	 */

	var src$5 = createCommonjsModule(function (module, exports) {

	const { Buffer } = require$$0;


	exports = module.exports = multibase;
	exports.encode = encode;
	exports.decode = decode;
	exports.isEncoded = isEncoded;
	exports.names = Object.freeze(Object.keys(constants_1$2.names));
	exports.codes = Object.freeze(Object.keys(constants_1$2.codes));

	/**
	 * Create a new buffer with the multibase varint+code.
	 *
	 * @param {string|number} nameOrCode - The multibase name or code number.
	 * @param {Buffer} buf - The data to be prefixed with multibase.
	 * @memberof Multibase
	 * @returns {Buffer}
	 */
	function multibase (nameOrCode, buf) {
	  if (!buf) {
	    throw new Error('requires an encoded buffer')
	  }
	  const base = getBase(nameOrCode);
	  const codeBuf = Buffer.from(base.code);

	  const name = base.name;
	  validEncode(name, buf);
	  return Buffer.concat([codeBuf, buf])
	}

	/**
	 * Encode data with the specified base and add the multibase prefix.
	 *
	 * @param {string|number} nameOrCode - The multibase name or code number.
	 * @param {Buffer} buf - The data to be encoded.
	 * @returns {Buffer}
	 * @memberof Multibase
	 */
	function encode (nameOrCode, buf) {
	  const base = getBase(nameOrCode);
	  const name = base.name;

	  return multibase(name, Buffer.from(base.encode(buf)))
	}

	/**
	 * Takes a buffer or string encoded with multibase header, decodes it and
	 * returns the decoded buffer
	 *
	 * @param {Buffer|string} bufOrString
	 * @returns {Buffer}
	 * @memberof Multibase
	 *
	 */
	function decode (bufOrString) {
	  if (Buffer.isBuffer(bufOrString)) {
	    bufOrString = bufOrString.toString();
	  }

	  const code = bufOrString.substring(0, 1);
	  bufOrString = bufOrString.substring(1, bufOrString.length);

	  if (typeof bufOrString === 'string') {
	    bufOrString = Buffer.from(bufOrString);
	  }

	  const base = getBase(code);
	  return Buffer.from(base.decode(bufOrString.toString()))
	}

	/**
	 * Is the given data multibase encoded?
	 *
	 * @param {Buffer|string} bufOrString
	 * @returns {boolean}
	 * @memberof Multibase
	 */
	function isEncoded (bufOrString) {
	  if (Buffer.isBuffer(bufOrString)) {
	    bufOrString = bufOrString.toString();
	  }

	  // Ensure bufOrString is a string
	  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
	    return false
	  }

	  const code = bufOrString.substring(0, 1);
	  try {
	    const base = getBase(code);
	    return base.name
	  } catch (err) {
	    return false
	  }
	}

	/**
	 * @param {string} name
	 * @param {Buffer} buf
	 * @private
	 * @returns {undefined}
	 */
	function validEncode (name, buf) {
	  const base = getBase(name);
	  base.decode(buf.toString());
	}

	function getBase (nameOrCode) {
	  let base;

	  if (constants_1$2.names[nameOrCode]) {
	    base = constants_1$2.names[nameOrCode];
	  } else if (constants_1$2.codes[nameOrCode]) {
	    base = constants_1$2.codes[nameOrCode];
	  } else {
	    throw new Error('Unsupported encoding')
	  }

	  if (!base.isImplemented()) {
	    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
	  }

	  return base
	}
	});

	/* eslint quote-props: off */

	var names$1 = Object.freeze({
	  'identity':   0x0,
	  'sha1':       0x11,
	  'sha2-256':   0x12,
	  'sha2-512':   0x13,
	  'dbl-sha2-256': 0x56,
	  'sha3-224':   0x17,
	  'sha3-256':   0x16,
	  'sha3-384':   0x15,
	  'sha3-512':   0x14,
	  'shake-128':  0x18,
	  'shake-256':  0x19,
	  'keccak-224': 0x1A,
	  'keccak-256': 0x1B,
	  'keccak-384': 0x1C,
	  'keccak-512': 0x1D,
	  'murmur3-128': 0x22,
	  'murmur3-32':  0x23,
	  'md4':         0xd4,
	  'md5':         0xd5,
	  'blake2b-8':   0xb201,
	  'blake2b-16':  0xb202,
	  'blake2b-24':  0xb203,
	  'blake2b-32':  0xb204,
	  'blake2b-40':  0xb205,
	  'blake2b-48':  0xb206,
	  'blake2b-56':  0xb207,
	  'blake2b-64':  0xb208,
	  'blake2b-72':  0xb209,
	  'blake2b-80':  0xb20a,
	  'blake2b-88':  0xb20b,
	  'blake2b-96':  0xb20c,
	  'blake2b-104': 0xb20d,
	  'blake2b-112': 0xb20e,
	  'blake2b-120': 0xb20f,
	  'blake2b-128': 0xb210,
	  'blake2b-136': 0xb211,
	  'blake2b-144': 0xb212,
	  'blake2b-152': 0xb213,
	  'blake2b-160': 0xb214,
	  'blake2b-168': 0xb215,
	  'blake2b-176': 0xb216,
	  'blake2b-184': 0xb217,
	  'blake2b-192': 0xb218,
	  'blake2b-200': 0xb219,
	  'blake2b-208': 0xb21a,
	  'blake2b-216': 0xb21b,
	  'blake2b-224': 0xb21c,
	  'blake2b-232': 0xb21d,
	  'blake2b-240': 0xb21e,
	  'blake2b-248': 0xb21f,
	  'blake2b-256': 0xb220,
	  'blake2b-264': 0xb221,
	  'blake2b-272': 0xb222,
	  'blake2b-280': 0xb223,
	  'blake2b-288': 0xb224,
	  'blake2b-296': 0xb225,
	  'blake2b-304': 0xb226,
	  'blake2b-312': 0xb227,
	  'blake2b-320': 0xb228,
	  'blake2b-328': 0xb229,
	  'blake2b-336': 0xb22a,
	  'blake2b-344': 0xb22b,
	  'blake2b-352': 0xb22c,
	  'blake2b-360': 0xb22d,
	  'blake2b-368': 0xb22e,
	  'blake2b-376': 0xb22f,
	  'blake2b-384': 0xb230,
	  'blake2b-392': 0xb231,
	  'blake2b-400': 0xb232,
	  'blake2b-408': 0xb233,
	  'blake2b-416': 0xb234,
	  'blake2b-424': 0xb235,
	  'blake2b-432': 0xb236,
	  'blake2b-440': 0xb237,
	  'blake2b-448': 0xb238,
	  'blake2b-456': 0xb239,
	  'blake2b-464': 0xb23a,
	  'blake2b-472': 0xb23b,
	  'blake2b-480': 0xb23c,
	  'blake2b-488': 0xb23d,
	  'blake2b-496': 0xb23e,
	  'blake2b-504': 0xb23f,
	  'blake2b-512': 0xb240,
	  'blake2s-8':   0xb241,
	  'blake2s-16':  0xb242,
	  'blake2s-24':  0xb243,
	  'blake2s-32':  0xb244,
	  'blake2s-40':  0xb245,
	  'blake2s-48':  0xb246,
	  'blake2s-56':  0xb247,
	  'blake2s-64':  0xb248,
	  'blake2s-72':  0xb249,
	  'blake2s-80':  0xb24a,
	  'blake2s-88':  0xb24b,
	  'blake2s-96':  0xb24c,
	  'blake2s-104': 0xb24d,
	  'blake2s-112': 0xb24e,
	  'blake2s-120': 0xb24f,
	  'blake2s-128': 0xb250,
	  'blake2s-136': 0xb251,
	  'blake2s-144': 0xb252,
	  'blake2s-152': 0xb253,
	  'blake2s-160': 0xb254,
	  'blake2s-168': 0xb255,
	  'blake2s-176': 0xb256,
	  'blake2s-184': 0xb257,
	  'blake2s-192': 0xb258,
	  'blake2s-200': 0xb259,
	  'blake2s-208': 0xb25a,
	  'blake2s-216': 0xb25b,
	  'blake2s-224': 0xb25c,
	  'blake2s-232': 0xb25d,
	  'blake2s-240': 0xb25e,
	  'blake2s-248': 0xb25f,
	  'blake2s-256': 0xb260,
	  'Skein256-8': 0xb301,
	  'Skein256-16': 0xb302,
	  'Skein256-24': 0xb303,
	  'Skein256-32': 0xb304,
	  'Skein256-40': 0xb305,
	  'Skein256-48': 0xb306,
	  'Skein256-56': 0xb307,
	  'Skein256-64': 0xb308,
	  'Skein256-72': 0xb309,
	  'Skein256-80': 0xb30a,
	  'Skein256-88': 0xb30b,
	  'Skein256-96': 0xb30c,
	  'Skein256-104': 0xb30d,
	  'Skein256-112': 0xb30e,
	  'Skein256-120': 0xb30f,
	  'Skein256-128': 0xb310,
	  'Skein256-136': 0xb311,
	  'Skein256-144': 0xb312,
	  'Skein256-152': 0xb313,
	  'Skein256-160': 0xb314,
	  'Skein256-168': 0xb315,
	  'Skein256-176': 0xb316,
	  'Skein256-184': 0xb317,
	  'Skein256-192': 0xb318,
	  'Skein256-200': 0xb319,
	  'Skein256-208': 0xb31a,
	  'Skein256-216': 0xb31b,
	  'Skein256-224': 0xb31c,
	  'Skein256-232': 0xb31d,
	  'Skein256-240': 0xb31e,
	  'Skein256-248': 0xb31f,
	  'Skein256-256': 0xb320,
	  'Skein512-8': 0xb321,
	  'Skein512-16': 0xb322,
	  'Skein512-24': 0xb323,
	  'Skein512-32': 0xb324,
	  'Skein512-40': 0xb325,
	  'Skein512-48': 0xb326,
	  'Skein512-56': 0xb327,
	  'Skein512-64': 0xb328,
	  'Skein512-72': 0xb329,
	  'Skein512-80': 0xb32a,
	  'Skein512-88': 0xb32b,
	  'Skein512-96': 0xb32c,
	  'Skein512-104': 0xb32d,
	  'Skein512-112': 0xb32e,
	  'Skein512-120': 0xb32f,
	  'Skein512-128': 0xb330,
	  'Skein512-136': 0xb331,
	  'Skein512-144': 0xb332,
	  'Skein512-152': 0xb333,
	  'Skein512-160': 0xb334,
	  'Skein512-168': 0xb335,
	  'Skein512-176': 0xb336,
	  'Skein512-184': 0xb337,
	  'Skein512-192': 0xb338,
	  'Skein512-200': 0xb339,
	  'Skein512-208': 0xb33a,
	  'Skein512-216': 0xb33b,
	  'Skein512-224': 0xb33c,
	  'Skein512-232': 0xb33d,
	  'Skein512-240': 0xb33e,
	  'Skein512-248': 0xb33f,
	  'Skein512-256': 0xb340,
	  'Skein512-264': 0xb341,
	  'Skein512-272': 0xb342,
	  'Skein512-280': 0xb343,
	  'Skein512-288': 0xb344,
	  'Skein512-296': 0xb345,
	  'Skein512-304': 0xb346,
	  'Skein512-312': 0xb347,
	  'Skein512-320': 0xb348,
	  'Skein512-328': 0xb349,
	  'Skein512-336': 0xb34a,
	  'Skein512-344': 0xb34b,
	  'Skein512-352': 0xb34c,
	  'Skein512-360': 0xb34d,
	  'Skein512-368': 0xb34e,
	  'Skein512-376': 0xb34f,
	  'Skein512-384': 0xb350,
	  'Skein512-392': 0xb351,
	  'Skein512-400': 0xb352,
	  'Skein512-408': 0xb353,
	  'Skein512-416': 0xb354,
	  'Skein512-424': 0xb355,
	  'Skein512-432': 0xb356,
	  'Skein512-440': 0xb357,
	  'Skein512-448': 0xb358,
	  'Skein512-456': 0xb359,
	  'Skein512-464': 0xb35a,
	  'Skein512-472': 0xb35b,
	  'Skein512-480': 0xb35c,
	  'Skein512-488': 0xb35d,
	  'Skein512-496': 0xb35e,
	  'Skein512-504': 0xb35f,
	  'Skein512-512': 0xb360,
	  'Skein1024-8': 0xb361,
	  'Skein1024-16': 0xb362,
	  'Skein1024-24': 0xb363,
	  'Skein1024-32': 0xb364,
	  'Skein1024-40': 0xb365,
	  'Skein1024-48': 0xb366,
	  'Skein1024-56': 0xb367,
	  'Skein1024-64': 0xb368,
	  'Skein1024-72': 0xb369,
	  'Skein1024-80': 0xb36a,
	  'Skein1024-88': 0xb36b,
	  'Skein1024-96': 0xb36c,
	  'Skein1024-104': 0xb36d,
	  'Skein1024-112': 0xb36e,
	  'Skein1024-120': 0xb36f,
	  'Skein1024-128': 0xb370,
	  'Skein1024-136': 0xb371,
	  'Skein1024-144': 0xb372,
	  'Skein1024-152': 0xb373,
	  'Skein1024-160': 0xb374,
	  'Skein1024-168': 0xb375,
	  'Skein1024-176': 0xb376,
	  'Skein1024-184': 0xb377,
	  'Skein1024-192': 0xb378,
	  'Skein1024-200': 0xb379,
	  'Skein1024-208': 0xb37a,
	  'Skein1024-216': 0xb37b,
	  'Skein1024-224': 0xb37c,
	  'Skein1024-232': 0xb37d,
	  'Skein1024-240': 0xb37e,
	  'Skein1024-248': 0xb37f,
	  'Skein1024-256': 0xb380,
	  'Skein1024-264': 0xb381,
	  'Skein1024-272': 0xb382,
	  'Skein1024-280': 0xb383,
	  'Skein1024-288': 0xb384,
	  'Skein1024-296': 0xb385,
	  'Skein1024-304': 0xb386,
	  'Skein1024-312': 0xb387,
	  'Skein1024-320': 0xb388,
	  'Skein1024-328': 0xb389,
	  'Skein1024-336': 0xb38a,
	  'Skein1024-344': 0xb38b,
	  'Skein1024-352': 0xb38c,
	  'Skein1024-360': 0xb38d,
	  'Skein1024-368': 0xb38e,
	  'Skein1024-376': 0xb38f,
	  'Skein1024-384': 0xb390,
	  'Skein1024-392': 0xb391,
	  'Skein1024-400': 0xb392,
	  'Skein1024-408': 0xb393,
	  'Skein1024-416': 0xb394,
	  'Skein1024-424': 0xb395,
	  'Skein1024-432': 0xb396,
	  'Skein1024-440': 0xb397,
	  'Skein1024-448': 0xb398,
	  'Skein1024-456': 0xb399,
	  'Skein1024-464': 0xb39a,
	  'Skein1024-472': 0xb39b,
	  'Skein1024-480': 0xb39c,
	  'Skein1024-488': 0xb39d,
	  'Skein1024-496': 0xb39e,
	  'Skein1024-504': 0xb39f,
	  'Skein1024-512': 0xb3a0,
	  'Skein1024-520': 0xb3a1,
	  'Skein1024-528': 0xb3a2,
	  'Skein1024-536': 0xb3a3,
	  'Skein1024-544': 0xb3a4,
	  'Skein1024-552': 0xb3a5,
	  'Skein1024-560': 0xb3a6,
	  'Skein1024-568': 0xb3a7,
	  'Skein1024-576': 0xb3a8,
	  'Skein1024-584': 0xb3a9,
	  'Skein1024-592': 0xb3aa,
	  'Skein1024-600': 0xb3ab,
	  'Skein1024-608': 0xb3ac,
	  'Skein1024-616': 0xb3ad,
	  'Skein1024-624': 0xb3ae,
	  'Skein1024-632': 0xb3af,
	  'Skein1024-640': 0xb3b0,
	  'Skein1024-648': 0xb3b1,
	  'Skein1024-656': 0xb3b2,
	  'Skein1024-664': 0xb3b3,
	  'Skein1024-672': 0xb3b4,
	  'Skein1024-680': 0xb3b5,
	  'Skein1024-688': 0xb3b6,
	  'Skein1024-696': 0xb3b7,
	  'Skein1024-704': 0xb3b8,
	  'Skein1024-712': 0xb3b9,
	  'Skein1024-720': 0xb3ba,
	  'Skein1024-728': 0xb3bb,
	  'Skein1024-736': 0xb3bc,
	  'Skein1024-744': 0xb3bd,
	  'Skein1024-752': 0xb3be,
	  'Skein1024-760': 0xb3bf,
	  'Skein1024-768': 0xb3c0,
	  'Skein1024-776': 0xb3c1,
	  'Skein1024-784': 0xb3c2,
	  'Skein1024-792': 0xb3c3,
	  'Skein1024-800': 0xb3c4,
	  'Skein1024-808': 0xb3c5,
	  'Skein1024-816': 0xb3c6,
	  'Skein1024-824': 0xb3c7,
	  'Skein1024-832': 0xb3c8,
	  'Skein1024-840': 0xb3c9,
	  'Skein1024-848': 0xb3ca,
	  'Skein1024-856': 0xb3cb,
	  'Skein1024-864': 0xb3cc,
	  'Skein1024-872': 0xb3cd,
	  'Skein1024-880': 0xb3ce,
	  'Skein1024-888': 0xb3cf,
	  'Skein1024-896': 0xb3d0,
	  'Skein1024-904': 0xb3d1,
	  'Skein1024-912': 0xb3d2,
	  'Skein1024-920': 0xb3d3,
	  'Skein1024-928': 0xb3d4,
	  'Skein1024-936': 0xb3d5,
	  'Skein1024-944': 0xb3d6,
	  'Skein1024-952': 0xb3d7,
	  'Skein1024-960': 0xb3d8,
	  'Skein1024-968': 0xb3d9,
	  'Skein1024-976': 0xb3da,
	  'Skein1024-984': 0xb3db,
	  'Skein1024-992': 0xb3dc,
	  'Skein1024-1000': 0xb3dd,
	  'Skein1024-1008': 0xb3de,
	  'Skein1024-1016': 0xb3df,
	  'Skein1024-1024': 0xb3e0
	});

	var codes$1 = Object.freeze({
	  0x0: 'identity',

	  // sha family
	  0x11: 'sha1',
	  0x12: 'sha2-256',
	  0x13: 'sha2-512',
	  0x56: 'dbl-sha2-256',
	  0x17: 'sha3-224',
	  0x16: 'sha3-256',
	  0x15: 'sha3-384',
	  0x14: 'sha3-512',
	  0x18: 'shake-128',
	  0x19: 'shake-256',
	  0x1A: 'keccak-224',
	  0x1B: 'keccak-256',
	  0x1C: 'keccak-384',
	  0x1D: 'keccak-512',

	  0x22: 'murmur3-128',
	  0x23: 'murmur3-32',

	  0xd4: 'md4',
	  0xd5: 'md5',

	  // blake2
	  0xb201: 'blake2b-8',
	  0xb202: 'blake2b-16',
	  0xb203: 'blake2b-24',
	  0xb204: 'blake2b-32',
	  0xb205: 'blake2b-40',
	  0xb206: 'blake2b-48',
	  0xb207: 'blake2b-56',
	  0xb208: 'blake2b-64',
	  0xb209: 'blake2b-72',
	  0xb20a: 'blake2b-80',
	  0xb20b: 'blake2b-88',
	  0xb20c: 'blake2b-96',
	  0xb20d: 'blake2b-104',
	  0xb20e: 'blake2b-112',
	  0xb20f: 'blake2b-120',
	  0xb210: 'blake2b-128',
	  0xb211: 'blake2b-136',
	  0xb212: 'blake2b-144',
	  0xb213: 'blake2b-152',
	  0xb214: 'blake2b-160',
	  0xb215: 'blake2b-168',
	  0xb216: 'blake2b-176',
	  0xb217: 'blake2b-184',
	  0xb218: 'blake2b-192',
	  0xb219: 'blake2b-200',
	  0xb21a: 'blake2b-208',
	  0xb21b: 'blake2b-216',
	  0xb21c: 'blake2b-224',
	  0xb21d: 'blake2b-232',
	  0xb21e: 'blake2b-240',
	  0xb21f: 'blake2b-248',
	  0xb220: 'blake2b-256',
	  0xb221: 'blake2b-264',
	  0xb222: 'blake2b-272',
	  0xb223: 'blake2b-280',
	  0xb224: 'blake2b-288',
	  0xb225: 'blake2b-296',
	  0xb226: 'blake2b-304',
	  0xb227: 'blake2b-312',
	  0xb228: 'blake2b-320',
	  0xb229: 'blake2b-328',
	  0xb22a: 'blake2b-336',
	  0xb22b: 'blake2b-344',
	  0xb22c: 'blake2b-352',
	  0xb22d: 'blake2b-360',
	  0xb22e: 'blake2b-368',
	  0xb22f: 'blake2b-376',
	  0xb230: 'blake2b-384',
	  0xb231: 'blake2b-392',
	  0xb232: 'blake2b-400',
	  0xb233: 'blake2b-408',
	  0xb234: 'blake2b-416',
	  0xb235: 'blake2b-424',
	  0xb236: 'blake2b-432',
	  0xb237: 'blake2b-440',
	  0xb238: 'blake2b-448',
	  0xb239: 'blake2b-456',
	  0xb23a: 'blake2b-464',
	  0xb23b: 'blake2b-472',
	  0xb23c: 'blake2b-480',
	  0xb23d: 'blake2b-488',
	  0xb23e: 'blake2b-496',
	  0xb23f: 'blake2b-504',
	  0xb240: 'blake2b-512',
	  0xb241: 'blake2s-8',
	  0xb242: 'blake2s-16',
	  0xb243: 'blake2s-24',
	  0xb244: 'blake2s-32',
	  0xb245: 'blake2s-40',
	  0xb246: 'blake2s-48',
	  0xb247: 'blake2s-56',
	  0xb248: 'blake2s-64',
	  0xb249: 'blake2s-72',
	  0xb24a: 'blake2s-80',
	  0xb24b: 'blake2s-88',
	  0xb24c: 'blake2s-96',
	  0xb24d: 'blake2s-104',
	  0xb24e: 'blake2s-112',
	  0xb24f: 'blake2s-120',
	  0xb250: 'blake2s-128',
	  0xb251: 'blake2s-136',
	  0xb252: 'blake2s-144',
	  0xb253: 'blake2s-152',
	  0xb254: 'blake2s-160',
	  0xb255: 'blake2s-168',
	  0xb256: 'blake2s-176',
	  0xb257: 'blake2s-184',
	  0xb258: 'blake2s-192',
	  0xb259: 'blake2s-200',
	  0xb25a: 'blake2s-208',
	  0xb25b: 'blake2s-216',
	  0xb25c: 'blake2s-224',
	  0xb25d: 'blake2s-232',
	  0xb25e: 'blake2s-240',
	  0xb25f: 'blake2s-248',
	  0xb260: 'blake2s-256',

	  // skein
	  0xb301: 'Skein256-8',
	  0xb302: 'Skein256-16',
	  0xb303: 'Skein256-24',
	  0xb304: 'Skein256-32',
	  0xb305: 'Skein256-40',
	  0xb306: 'Skein256-48',
	  0xb307: 'Skein256-56',
	  0xb308: 'Skein256-64',
	  0xb309: 'Skein256-72',
	  0xb30a: 'Skein256-80',
	  0xb30b: 'Skein256-88',
	  0xb30c: 'Skein256-96',
	  0xb30d: 'Skein256-104',
	  0xb30e: 'Skein256-112',
	  0xb30f: 'Skein256-120',
	  0xb310: 'Skein256-128',
	  0xb311: 'Skein256-136',
	  0xb312: 'Skein256-144',
	  0xb313: 'Skein256-152',
	  0xb314: 'Skein256-160',
	  0xb315: 'Skein256-168',
	  0xb316: 'Skein256-176',
	  0xb317: 'Skein256-184',
	  0xb318: 'Skein256-192',
	  0xb319: 'Skein256-200',
	  0xb31a: 'Skein256-208',
	  0xb31b: 'Skein256-216',
	  0xb31c: 'Skein256-224',
	  0xb31d: 'Skein256-232',
	  0xb31e: 'Skein256-240',
	  0xb31f: 'Skein256-248',
	  0xb320: 'Skein256-256',
	  0xb321: 'Skein512-8',
	  0xb322: 'Skein512-16',
	  0xb323: 'Skein512-24',
	  0xb324: 'Skein512-32',
	  0xb325: 'Skein512-40',
	  0xb326: 'Skein512-48',
	  0xb327: 'Skein512-56',
	  0xb328: 'Skein512-64',
	  0xb329: 'Skein512-72',
	  0xb32a: 'Skein512-80',
	  0xb32b: 'Skein512-88',
	  0xb32c: 'Skein512-96',
	  0xb32d: 'Skein512-104',
	  0xb32e: 'Skein512-112',
	  0xb32f: 'Skein512-120',
	  0xb330: 'Skein512-128',
	  0xb331: 'Skein512-136',
	  0xb332: 'Skein512-144',
	  0xb333: 'Skein512-152',
	  0xb334: 'Skein512-160',
	  0xb335: 'Skein512-168',
	  0xb336: 'Skein512-176',
	  0xb337: 'Skein512-184',
	  0xb338: 'Skein512-192',
	  0xb339: 'Skein512-200',
	  0xb33a: 'Skein512-208',
	  0xb33b: 'Skein512-216',
	  0xb33c: 'Skein512-224',
	  0xb33d: 'Skein512-232',
	  0xb33e: 'Skein512-240',
	  0xb33f: 'Skein512-248',
	  0xb340: 'Skein512-256',
	  0xb341: 'Skein512-264',
	  0xb342: 'Skein512-272',
	  0xb343: 'Skein512-280',
	  0xb344: 'Skein512-288',
	  0xb345: 'Skein512-296',
	  0xb346: 'Skein512-304',
	  0xb347: 'Skein512-312',
	  0xb348: 'Skein512-320',
	  0xb349: 'Skein512-328',
	  0xb34a: 'Skein512-336',
	  0xb34b: 'Skein512-344',
	  0xb34c: 'Skein512-352',
	  0xb34d: 'Skein512-360',
	  0xb34e: 'Skein512-368',
	  0xb34f: 'Skein512-376',
	  0xb350: 'Skein512-384',
	  0xb351: 'Skein512-392',
	  0xb352: 'Skein512-400',
	  0xb353: 'Skein512-408',
	  0xb354: 'Skein512-416',
	  0xb355: 'Skein512-424',
	  0xb356: 'Skein512-432',
	  0xb357: 'Skein512-440',
	  0xb358: 'Skein512-448',
	  0xb359: 'Skein512-456',
	  0xb35a: 'Skein512-464',
	  0xb35b: 'Skein512-472',
	  0xb35c: 'Skein512-480',
	  0xb35d: 'Skein512-488',
	  0xb35e: 'Skein512-496',
	  0xb35f: 'Skein512-504',
	  0xb360: 'Skein512-512',
	  0xb361: 'Skein1024-8',
	  0xb362: 'Skein1024-16',
	  0xb363: 'Skein1024-24',
	  0xb364: 'Skein1024-32',
	  0xb365: 'Skein1024-40',
	  0xb366: 'Skein1024-48',
	  0xb367: 'Skein1024-56',
	  0xb368: 'Skein1024-64',
	  0xb369: 'Skein1024-72',
	  0xb36a: 'Skein1024-80',
	  0xb36b: 'Skein1024-88',
	  0xb36c: 'Skein1024-96',
	  0xb36d: 'Skein1024-104',
	  0xb36e: 'Skein1024-112',
	  0xb36f: 'Skein1024-120',
	  0xb370: 'Skein1024-128',
	  0xb371: 'Skein1024-136',
	  0xb372: 'Skein1024-144',
	  0xb373: 'Skein1024-152',
	  0xb374: 'Skein1024-160',
	  0xb375: 'Skein1024-168',
	  0xb376: 'Skein1024-176',
	  0xb377: 'Skein1024-184',
	  0xb378: 'Skein1024-192',
	  0xb379: 'Skein1024-200',
	  0xb37a: 'Skein1024-208',
	  0xb37b: 'Skein1024-216',
	  0xb37c: 'Skein1024-224',
	  0xb37d: 'Skein1024-232',
	  0xb37e: 'Skein1024-240',
	  0xb37f: 'Skein1024-248',
	  0xb380: 'Skein1024-256',
	  0xb381: 'Skein1024-264',
	  0xb382: 'Skein1024-272',
	  0xb383: 'Skein1024-280',
	  0xb384: 'Skein1024-288',
	  0xb385: 'Skein1024-296',
	  0xb386: 'Skein1024-304',
	  0xb387: 'Skein1024-312',
	  0xb388: 'Skein1024-320',
	  0xb389: 'Skein1024-328',
	  0xb38a: 'Skein1024-336',
	  0xb38b: 'Skein1024-344',
	  0xb38c: 'Skein1024-352',
	  0xb38d: 'Skein1024-360',
	  0xb38e: 'Skein1024-368',
	  0xb38f: 'Skein1024-376',
	  0xb390: 'Skein1024-384',
	  0xb391: 'Skein1024-392',
	  0xb392: 'Skein1024-400',
	  0xb393: 'Skein1024-408',
	  0xb394: 'Skein1024-416',
	  0xb395: 'Skein1024-424',
	  0xb396: 'Skein1024-432',
	  0xb397: 'Skein1024-440',
	  0xb398: 'Skein1024-448',
	  0xb399: 'Skein1024-456',
	  0xb39a: 'Skein1024-464',
	  0xb39b: 'Skein1024-472',
	  0xb39c: 'Skein1024-480',
	  0xb39d: 'Skein1024-488',
	  0xb39e: 'Skein1024-496',
	  0xb39f: 'Skein1024-504',
	  0xb3a0: 'Skein1024-512',
	  0xb3a1: 'Skein1024-520',
	  0xb3a2: 'Skein1024-528',
	  0xb3a3: 'Skein1024-536',
	  0xb3a4: 'Skein1024-544',
	  0xb3a5: 'Skein1024-552',
	  0xb3a6: 'Skein1024-560',
	  0xb3a7: 'Skein1024-568',
	  0xb3a8: 'Skein1024-576',
	  0xb3a9: 'Skein1024-584',
	  0xb3aa: 'Skein1024-592',
	  0xb3ab: 'Skein1024-600',
	  0xb3ac: 'Skein1024-608',
	  0xb3ad: 'Skein1024-616',
	  0xb3ae: 'Skein1024-624',
	  0xb3af: 'Skein1024-632',
	  0xb3b0: 'Skein1024-640',
	  0xb3b1: 'Skein1024-648',
	  0xb3b2: 'Skein1024-656',
	  0xb3b3: 'Skein1024-664',
	  0xb3b4: 'Skein1024-672',
	  0xb3b5: 'Skein1024-680',
	  0xb3b6: 'Skein1024-688',
	  0xb3b7: 'Skein1024-696',
	  0xb3b8: 'Skein1024-704',
	  0xb3b9: 'Skein1024-712',
	  0xb3ba: 'Skein1024-720',
	  0xb3bb: 'Skein1024-728',
	  0xb3bc: 'Skein1024-736',
	  0xb3bd: 'Skein1024-744',
	  0xb3be: 'Skein1024-752',
	  0xb3bf: 'Skein1024-760',
	  0xb3c0: 'Skein1024-768',
	  0xb3c1: 'Skein1024-776',
	  0xb3c2: 'Skein1024-784',
	  0xb3c3: 'Skein1024-792',
	  0xb3c4: 'Skein1024-800',
	  0xb3c5: 'Skein1024-808',
	  0xb3c6: 'Skein1024-816',
	  0xb3c7: 'Skein1024-824',
	  0xb3c8: 'Skein1024-832',
	  0xb3c9: 'Skein1024-840',
	  0xb3ca: 'Skein1024-848',
	  0xb3cb: 'Skein1024-856',
	  0xb3cc: 'Skein1024-864',
	  0xb3cd: 'Skein1024-872',
	  0xb3ce: 'Skein1024-880',
	  0xb3cf: 'Skein1024-888',
	  0xb3d0: 'Skein1024-896',
	  0xb3d1: 'Skein1024-904',
	  0xb3d2: 'Skein1024-912',
	  0xb3d3: 'Skein1024-920',
	  0xb3d4: 'Skein1024-928',
	  0xb3d5: 'Skein1024-936',
	  0xb3d6: 'Skein1024-944',
	  0xb3d7: 'Skein1024-952',
	  0xb3d8: 'Skein1024-960',
	  0xb3d9: 'Skein1024-968',
	  0xb3da: 'Skein1024-976',
	  0xb3db: 'Skein1024-984',
	  0xb3dc: 'Skein1024-992',
	  0xb3dd: 'Skein1024-1000',
	  0xb3de: 'Skein1024-1008',
	  0xb3df: 'Skein1024-1016',
	  0xb3e0: 'Skein1024-1024'
	});

	var defaultLengths = Object.freeze({
	  0x11: 20,
	  0x12: 32,
	  0x13: 64,
	  0x56: 32,
	  0x17: 28,
	  0x16: 32,
	  0x15: 48,
	  0x14: 64,
	  0x18: 32,
	  0x19: 64,
	  0x1A: 28,
	  0x1B: 32,
	  0x1C: 48,
	  0x1D: 64,
	  0x22: 32,

	  0xb201: 0x01,
	  0xb202: 0x02,
	  0xb203: 0x03,
	  0xb204: 0x04,
	  0xb205: 0x05,
	  0xb206: 0x06,
	  0xb207: 0x07,
	  0xb208: 0x08,
	  0xb209: 0x09,
	  0xb20a: 0x0a,
	  0xb20b: 0x0b,
	  0xb20c: 0x0c,
	  0xb20d: 0x0d,
	  0xb20e: 0x0e,
	  0xb20f: 0x0f,
	  0xb210: 0x10,
	  0xb211: 0x11,
	  0xb212: 0x12,
	  0xb213: 0x13,
	  0xb214: 0x14,
	  0xb215: 0x15,
	  0xb216: 0x16,
	  0xb217: 0x17,
	  0xb218: 0x18,
	  0xb219: 0x19,
	  0xb21a: 0x1a,
	  0xb21b: 0x1b,
	  0xb21c: 0x1c,
	  0xb21d: 0x1d,
	  0xb21e: 0x1e,
	  0xb21f: 0x1f,
	  0xb220: 0x20,
	  0xb221: 0x21,
	  0xb222: 0x22,
	  0xb223: 0x23,
	  0xb224: 0x24,
	  0xb225: 0x25,
	  0xb226: 0x26,
	  0xb227: 0x27,
	  0xb228: 0x28,
	  0xb229: 0x29,
	  0xb22a: 0x2a,
	  0xb22b: 0x2b,
	  0xb22c: 0x2c,
	  0xb22d: 0x2d,
	  0xb22e: 0x2e,
	  0xb22f: 0x2f,
	  0xb230: 0x30,
	  0xb231: 0x31,
	  0xb232: 0x32,
	  0xb233: 0x33,
	  0xb234: 0x34,
	  0xb235: 0x35,
	  0xb236: 0x36,
	  0xb237: 0x37,
	  0xb238: 0x38,
	  0xb239: 0x39,
	  0xb23a: 0x3a,
	  0xb23b: 0x3b,
	  0xb23c: 0x3c,
	  0xb23d: 0x3d,
	  0xb23e: 0x3e,
	  0xb23f: 0x3f,
	  0xb240: 0x40,
	  0xb241: 0x01,
	  0xb242: 0x02,
	  0xb243: 0x03,
	  0xb244: 0x04,
	  0xb245: 0x05,
	  0xb246: 0x06,
	  0xb247: 0x07,
	  0xb248: 0x08,
	  0xb249: 0x09,
	  0xb24a: 0x0a,
	  0xb24b: 0x0b,
	  0xb24c: 0x0c,
	  0xb24d: 0x0d,
	  0xb24e: 0x0e,
	  0xb24f: 0x0f,
	  0xb250: 0x10,
	  0xb251: 0x11,
	  0xb252: 0x12,
	  0xb253: 0x13,
	  0xb254: 0x14,
	  0xb255: 0x15,
	  0xb256: 0x16,
	  0xb257: 0x17,
	  0xb258: 0x18,
	  0xb259: 0x19,
	  0xb25a: 0x1a,
	  0xb25b: 0x1b,
	  0xb25c: 0x1c,
	  0xb25d: 0x1d,
	  0xb25e: 0x1e,
	  0xb25f: 0x1f,
	  0xb260: 0x20,
	  0xb301: 0x01,
	  0xb302: 0x02,
	  0xb303: 0x03,
	  0xb304: 0x04,
	  0xb305: 0x05,
	  0xb306: 0x06,
	  0xb307: 0x07,
	  0xb308: 0x08,
	  0xb309: 0x09,
	  0xb30a: 0x0a,
	  0xb30b: 0x0b,
	  0xb30c: 0x0c,
	  0xb30d: 0x0d,
	  0xb30e: 0x0e,
	  0xb30f: 0x0f,
	  0xb310: 0x10,
	  0xb311: 0x11,
	  0xb312: 0x12,
	  0xb313: 0x13,
	  0xb314: 0x14,
	  0xb315: 0x15,
	  0xb316: 0x16,
	  0xb317: 0x17,
	  0xb318: 0x18,
	  0xb319: 0x19,
	  0xb31a: 0x1a,
	  0xb31b: 0x1b,
	  0xb31c: 0x1c,
	  0xb31d: 0x1d,
	  0xb31e: 0x1e,
	  0xb31f: 0x1f,
	  0xb320: 0x20,
	  0xb321: 0x01,
	  0xb322: 0x02,
	  0xb323: 0x03,
	  0xb324: 0x04,
	  0xb325: 0x05,
	  0xb326: 0x06,
	  0xb327: 0x07,
	  0xb328: 0x08,
	  0xb329: 0x09,
	  0xb32a: 0x0a,
	  0xb32b: 0x0b,
	  0xb32c: 0x0c,
	  0xb32d: 0x0d,
	  0xb32e: 0x0e,
	  0xb32f: 0x0f,
	  0xb330: 0x10,
	  0xb331: 0x11,
	  0xb332: 0x12,
	  0xb333: 0x13,
	  0xb334: 0x14,
	  0xb335: 0x15,
	  0xb336: 0x16,
	  0xb337: 0x17,
	  0xb338: 0x18,
	  0xb339: 0x19,
	  0xb33a: 0x1a,
	  0xb33b: 0x1b,
	  0xb33c: 0x1c,
	  0xb33d: 0x1d,
	  0xb33e: 0x1e,
	  0xb33f: 0x1f,
	  0xb340: 0x20,
	  0xb341: 0x21,
	  0xb342: 0x22,
	  0xb343: 0x23,
	  0xb344: 0x24,
	  0xb345: 0x25,
	  0xb346: 0x26,
	  0xb347: 0x27,
	  0xb348: 0x28,
	  0xb349: 0x29,
	  0xb34a: 0x2a,
	  0xb34b: 0x2b,
	  0xb34c: 0x2c,
	  0xb34d: 0x2d,
	  0xb34e: 0x2e,
	  0xb34f: 0x2f,
	  0xb350: 0x30,
	  0xb351: 0x31,
	  0xb352: 0x32,
	  0xb353: 0x33,
	  0xb354: 0x34,
	  0xb355: 0x35,
	  0xb356: 0x36,
	  0xb357: 0x37,
	  0xb358: 0x38,
	  0xb359: 0x39,
	  0xb35a: 0x3a,
	  0xb35b: 0x3b,
	  0xb35c: 0x3c,
	  0xb35d: 0x3d,
	  0xb35e: 0x3e,
	  0xb35f: 0x3f,
	  0xb360: 0x40,
	  0xb361: 0x01,
	  0xb362: 0x02,
	  0xb363: 0x03,
	  0xb364: 0x04,
	  0xb365: 0x05,
	  0xb366: 0x06,
	  0xb367: 0x07,
	  0xb368: 0x08,
	  0xb369: 0x09,
	  0xb36a: 0x0a,
	  0xb36b: 0x0b,
	  0xb36c: 0x0c,
	  0xb36d: 0x0d,
	  0xb36e: 0x0e,
	  0xb36f: 0x0f,
	  0xb370: 0x10,
	  0xb371: 0x11,
	  0xb372: 0x12,
	  0xb373: 0x13,
	  0xb374: 0x14,
	  0xb375: 0x15,
	  0xb376: 0x16,
	  0xb377: 0x17,
	  0xb378: 0x18,
	  0xb379: 0x19,
	  0xb37a: 0x1a,
	  0xb37b: 0x1b,
	  0xb37c: 0x1c,
	  0xb37d: 0x1d,
	  0xb37e: 0x1e,
	  0xb37f: 0x1f,
	  0xb380: 0x20,
	  0xb381: 0x21,
	  0xb382: 0x22,
	  0xb383: 0x23,
	  0xb384: 0x24,
	  0xb385: 0x25,
	  0xb386: 0x26,
	  0xb387: 0x27,
	  0xb388: 0x28,
	  0xb389: 0x29,
	  0xb38a: 0x2a,
	  0xb38b: 0x2b,
	  0xb38c: 0x2c,
	  0xb38d: 0x2d,
	  0xb38e: 0x2e,
	  0xb38f: 0x2f,
	  0xb390: 0x30,
	  0xb391: 0x31,
	  0xb392: 0x32,
	  0xb393: 0x33,
	  0xb394: 0x34,
	  0xb395: 0x35,
	  0xb396: 0x36,
	  0xb397: 0x37,
	  0xb398: 0x38,
	  0xb399: 0x39,
	  0xb39a: 0x3a,
	  0xb39b: 0x3b,
	  0xb39c: 0x3c,
	  0xb39d: 0x3d,
	  0xb39e: 0x3e,
	  0xb39f: 0x3f,
	  0xb3a0: 0x40,
	  0xb3a1: 0x41,
	  0xb3a2: 0x42,
	  0xb3a3: 0x43,
	  0xb3a4: 0x44,
	  0xb3a5: 0x45,
	  0xb3a6: 0x46,
	  0xb3a7: 0x47,
	  0xb3a8: 0x48,
	  0xb3a9: 0x49,
	  0xb3aa: 0x4a,
	  0xb3ab: 0x4b,
	  0xb3ac: 0x4c,
	  0xb3ad: 0x4d,
	  0xb3ae: 0x4e,
	  0xb3af: 0x4f,
	  0xb3b0: 0x50,
	  0xb3b1: 0x51,
	  0xb3b2: 0x52,
	  0xb3b3: 0x53,
	  0xb3b4: 0x54,
	  0xb3b5: 0x55,
	  0xb3b6: 0x56,
	  0xb3b7: 0x57,
	  0xb3b8: 0x58,
	  0xb3b9: 0x59,
	  0xb3ba: 0x5a,
	  0xb3bb: 0x5b,
	  0xb3bc: 0x5c,
	  0xb3bd: 0x5d,
	  0xb3be: 0x5e,
	  0xb3bf: 0x5f,
	  0xb3c0: 0x60,
	  0xb3c1: 0x61,
	  0xb3c2: 0x62,
	  0xb3c3: 0x63,
	  0xb3c4: 0x64,
	  0xb3c5: 0x65,
	  0xb3c6: 0x66,
	  0xb3c7: 0x67,
	  0xb3c8: 0x68,
	  0xb3c9: 0x69,
	  0xb3ca: 0x6a,
	  0xb3cb: 0x6b,
	  0xb3cc: 0x6c,
	  0xb3cd: 0x6d,
	  0xb3ce: 0x6e,
	  0xb3cf: 0x6f,
	  0xb3d0: 0x70,
	  0xb3d1: 0x71,
	  0xb3d2: 0x72,
	  0xb3d3: 0x73,
	  0xb3d4: 0x74,
	  0xb3d5: 0x75,
	  0xb3d6: 0x76,
	  0xb3d7: 0x77,
	  0xb3d8: 0x78,
	  0xb3d9: 0x79,
	  0xb3da: 0x7a,
	  0xb3db: 0x7b,
	  0xb3dc: 0x7c,
	  0xb3dd: 0x7d,
	  0xb3de: 0x7e,
	  0xb3df: 0x7f,
	  0xb3e0: 0x80
	});

	var constants$2 = {
		names: names$1,
		codes: codes$1,
		defaultLengths: defaultLengths
	};

	/**
	 * Multihash implementation in JavaScript.
	 *
	 * @module multihash
	 */

	var src$4 = createCommonjsModule(function (module, exports) {

	const { Buffer } = require$$0;




	exports.names = constants$2.names;
	exports.codes = constants$2.codes;
	exports.defaultLengths = constants$2.defaultLengths;

	/**
	 * Convert the given multihash to a hex encoded string.
	 *
	 * @param {Buffer} hash
	 * @returns {string}
	 */
	exports.toHexString = function toHexString (hash) {
	  if (!Buffer.isBuffer(hash)) {
	    throw new Error('must be passed a buffer')
	  }

	  return hash.toString('hex')
	};

	/**
	 * Convert the given hex encoded string to a multihash.
	 *
	 * @param {string} hash
	 * @returns {Buffer}
	 */
	exports.fromHexString = function fromHexString (hash) {
	  return Buffer.from(hash, 'hex')
	};

	/**
	 * Convert the given multihash to a base58 encoded string.
	 *
	 * @param {Buffer} hash
	 * @returns {string}
	 */
	exports.toB58String = function toB58String (hash) {
	  if (!Buffer.isBuffer(hash)) {
	    throw new Error('must be passed a buffer')
	  }

	  return src$5.encode('base58btc', hash).toString().slice(1)
	};

	/**
	 * Convert the given base58 encoded string to a multihash.
	 *
	 * @param {string|Buffer} hash
	 * @returns {Buffer}
	 */
	exports.fromB58String = function fromB58String (hash) {
	  let encoded = hash;
	  if (Buffer.isBuffer(hash)) {
	    encoded = hash.toString();
	  }

	  return src$5.decode('z' + encoded)
	};

	/**
	 * Decode a hash from the given multihash.
	 *
	 * @param {Buffer} buf
	 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
	 */
	exports.decode = function decode (buf) {
	  if (!(Buffer.isBuffer(buf))) {
	    throw new Error('multihash must be a Buffer')
	  }

	  if (buf.length < 2) {
	    throw new Error('multihash too short. must be > 2 bytes.')
	  }

	  const code = varint.decode(buf);
	  if (!exports.isValidCode(code)) {
	    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
	  }
	  buf = buf.slice(varint.decode.bytes);

	  const len = varint.decode(buf);
	  if (len < 0) {
	    throw new Error(`multihash invalid length: ${len}`)
	  }
	  buf = buf.slice(varint.decode.bytes);

	  if (buf.length !== len) {
	    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
	  }

	  return {
	    code: code,
	    name: constants$2.codes[code],
	    length: len,
	    digest: buf
	  }
	};

	/**
	 *  Encode a hash digest along with the specified function code.
	 *
	 * > **Note:** the length is derived from the length of the digest itself.
	 *
	 * @param {Buffer} digest
	 * @param {string|number} code
	 * @param {number} [length]
	 * @returns {Buffer}
	 */
	exports.encode = function encode (digest, code, length) {
	  if (!digest || code === undefined) {
	    throw new Error('multihash encode requires at least two args: digest, code')
	  }

	  // ensure it's a hashfunction code.
	  const hashfn = exports.coerceCode(code);

	  if (!(Buffer.isBuffer(digest))) {
	    throw new Error('digest should be a Buffer')
	  }

	  if (length == null) {
	    length = digest.length;
	  }

	  if (length && digest.length !== length) {
	    throw new Error('digest length should be equal to specified length.')
	  }

	  return Buffer.concat([
	    Buffer.from(varint.encode(hashfn)),
	    Buffer.from(varint.encode(length)),
	    digest
	  ])
	};

	/**
	 * Converts a hash function name into the matching code.
	 * If passed a number it will return the number if it's a valid code.
	 * @param {string|number} name
	 * @returns {number}
	 */
	exports.coerceCode = function coerceCode (name) {
	  let code = name;

	  if (typeof name === 'string') {
	    if (constants$2.names[name] === undefined) {
	      throw new Error(`Unrecognized hash function named: ${name}`)
	    }
	    code = constants$2.names[name];
	  }

	  if (typeof code !== 'number') {
	    throw new Error(`Hash function code should be a number. Got: ${code}`)
	  }

	  if (constants$2.codes[code] === undefined && !exports.isAppCode(code)) {
	    throw new Error(`Unrecognized function code: ${code}`)
	  }

	  return code
	};

	/**
	 * Checks wether a code is part of the app range
	 *
	 * @param {number} code
	 * @returns {boolean}
	 */
	exports.isAppCode = function appCode (code) {
	  return code > 0 && code < 0x10
	};

	/**
	 * Checks whether a multihash code is valid.
	 *
	 * @param {number} code
	 * @returns {boolean}
	 */
	exports.isValidCode = function validCode (code) {
	  if (exports.isAppCode(code)) {
	    return true
	  }

	  if (constants$2.codes[code]) {
	    return true
	  }

	  return false
	};

	/**
	 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
	 *
	 * @param {Buffer} multihash
	 * @returns {undefined}
	 * @throws {Error}
	 */
	function validate (multihash) {
	  exports.decode(multihash); // throws if bad.
	}
	exports.validate = validate;

	/**
	 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
	 *
	 * @param {Buffer} multihash
	 * @returns {undefined}
	 * @throws {Error}
	 */
	exports.prefix = function prefix (multihash) {
	  validate(multihash);

	  return multihash.slice(0, 2)
	};
	});

	class Base {
	  constructor (name, code, implementation, alphabet) {
	    this.name = name;
	    this.code = code;
	    this.alphabet = alphabet;
	    if (implementation && alphabet) {
	      this.engine = implementation(alphabet);
	    }
	  }

	  encode (stringOrBuffer) {
	    return this.engine.encode(stringOrBuffer)
	  }

	  decode (stringOrBuffer) {
	    return this.engine.decode(stringOrBuffer)
	  }

	  isImplemented () {
	    return this.engine
	  }
	}

	var base = Base;

	const { Buffer: Buffer$5 } = require$$0;

	var base16 = function base16 (alphabet) {
	  return {
	    encode (input) {
	      if (typeof input === 'string') {
	        return Buffer$5.from(input).toString('hex')
	      }
	      return input.toString('hex')
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base16 character')
	        }
	      }
	      return Buffer$5.from(input, 'hex')
	    }
	  }
	};

	function decode (input, alphabet) {
	  input = input.replace(new RegExp('=', 'g'), '');
	  const length = input.length;

	  let bits = 0;
	  let value = 0;

	  let index = 0;
	  const output = new Uint8Array((length * 5 / 8) | 0);

	  for (let i = 0; i < length; i++) {
	    value = (value << 5) | alphabet.indexOf(input[i]);
	    bits += 5;

	    if (bits >= 8) {
	      output[index++] = (value >>> (bits - 8)) & 255;
	      bits -= 8;
	    }
	  }

	  return output.buffer
	}

	function encode (buffer, alphabet) {
	  const length = buffer.byteLength;
	  const view = new Uint8Array(buffer);
	  const padding = alphabet.indexOf('=') === alphabet.length - 1;

	  if (padding) {
	    alphabet = alphabet.substring(0, alphabet.length - 1);
	  }

	  let bits = 0;
	  let value = 0;
	  let output = '';

	  for (let i = 0; i < length; i++) {
	    value = (value << 8) | view[i];
	    bits += 8;

	    while (bits >= 5) {
	      output += alphabet[(value >>> (bits - 5)) & 31];
	      bits -= 5;
	    }
	  }

	  if (bits > 0) {
	    output += alphabet[(value << (5 - bits)) & 31];
	  }

	  if (padding) {
	    while ((output.length % 8) !== 0) {
	      output += '=';
	    }
	  }

	  return output
	}

	var base32 = function base32 (alphabet) {
	  return {
	    encode (input) {
	      if (typeof input === 'string') {
	        return encode(Uint8Array.from(input), alphabet)
	      }

	      return encode(input, alphabet)
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base32 character')
	        }
	      }

	      return decode(input, alphabet)
	    }
	  }
	};

	const { Buffer: Buffer$4 } = require$$0;

	var base64 = function base64 (alphabet) {
	  // The alphabet is only used to know:
	  //   1. If padding is enabled (must contain '=')
	  //   2. If the output must be url-safe (must contain '-' and '_')
	  //   3. If the input of the output function is valid
	  // The alphabets from RFC 4648 are always used.
	  const padding = alphabet.indexOf('=') > -1;
	  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1;

	  return {
	    encode (input) {
	      let output = '';

	      if (typeof input === 'string') {
	        output = Buffer$4.from(input).toString('base64');
	      } else {
	        output = input.toString('base64');
	      }

	      if (url) {
	        output = output.replace(/\+/g, '-').replace(/\//g, '_');
	      }

	      const pad = output.indexOf('=');
	      if (pad > 0 && !padding) {
	        output = output.substring(0, pad);
	      }

	      return output
	    },
	    decode (input) {
	      for (const char of input) {
	        if (alphabet.indexOf(char) < 0) {
	          throw new Error('invalid base64 character')
	        }
	      }

	      return Buffer$4.from(input, 'base64')
	    }
	  }
	};

	// name, code, implementation, alphabet
	const constants$1 = [
	  ['base1', '1', '', '1'],
	  ['base2', '0', src$6, '01'],
	  ['base8', '7', src$6, '01234567'],
	  ['base10', '9', src$6, '0123456789'],
	  ['base16', 'f', base16, '0123456789abcdef'],
	  ['base32', 'b', base32, 'abcdefghijklmnopqrstuvwxyz234567'],
	  ['base32pad', 'c', base32, 'abcdefghijklmnopqrstuvwxyz234567='],
	  ['base32hex', 'v', base32, '0123456789abcdefghijklmnopqrstuv'],
	  ['base32hexpad', 't', base32, '0123456789abcdefghijklmnopqrstuv='],
	  ['base32z', 'h', base32, 'ybndrfg8ejkmcpqxot1uwisza345h769'],
	  ['base58flickr', 'Z', src$6, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
	  ['base58btc', 'z', src$6, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
	  ['base64', 'm', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
	  ['base64pad', 'M', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
	  ['base64url', 'u', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
	  ['base64urlpad', 'U', base64, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
	];

	const names = constants$1.reduce((prev, tupple) => {
	  prev[tupple[0]] = new base(tupple[0], tupple[1], tupple[2], tupple[3]);
	  return prev
	}, {});

	const codes = constants$1.reduce((prev, tupple) => {
	  prev[tupple[1]] = names[tupple[0]];
	  return prev
	}, {});

	var constants_1$1 = {
	  names: names,
	  codes: codes
	};

	/**
	 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
	 * @module Multibase
	 */

	var src$3 = createCommonjsModule(function (module, exports) {

	const { Buffer } = require$$0;


	exports = module.exports = multibase;
	exports.encode = encode;
	exports.decode = decode;
	exports.isEncoded = isEncoded;
	exports.names = Object.freeze(Object.keys(constants_1$1.names));
	exports.codes = Object.freeze(Object.keys(constants_1$1.codes));

	const errNotSupported = new Error('Unsupported encoding');

	/**
	 * Create a new buffer with the multibase varint+code.
	 *
	 * @param {string|number} nameOrCode - The multibase name or code number.
	 * @param {Buffer} buf - The data to be prefixed with multibase.
	 * @memberof Multibase
	 * @returns {Buffer}
	 */
	function multibase (nameOrCode, buf) {
	  if (!buf) {
	    throw new Error('requires an encoded buffer')
	  }
	  const base = getBase(nameOrCode);
	  const codeBuf = Buffer.from(base.code);

	  const name = base.name;
	  validEncode(name, buf);
	  return Buffer.concat([codeBuf, buf])
	}

	/**
	 * Encode data with the specified base and add the multibase prefix.
	 *
	 * @param {string|number} nameOrCode - The multibase name or code number.
	 * @param {Buffer} buf - The data to be encoded.
	 * @returns {Buffer}
	 * @memberof Multibase
	 */
	function encode (nameOrCode, buf) {
	  const base = getBase(nameOrCode);
	  const name = base.name;

	  return multibase(name, Buffer.from(base.encode(buf)))
	}

	/**
	 * Takes a buffer or string encoded with multibase header, decodes it and
	 * returns the decoded buffer
	 *
	 * @param {Buffer|string} bufOrString
	 * @returns {Buffer}
	 * @memberof Multibase
	 *
	 */
	function decode (bufOrString) {
	  if (Buffer.isBuffer(bufOrString)) {
	    bufOrString = bufOrString.toString();
	  }

	  const code = bufOrString.substring(0, 1);
	  bufOrString = bufOrString.substring(1, bufOrString.length);

	  if (typeof bufOrString === 'string') {
	    bufOrString = Buffer.from(bufOrString);
	  }

	  const base = getBase(code);
	  return Buffer.from(base.decode(bufOrString.toString()))
	}

	/**
	 * Is the given data multibase encoded?
	 *
	 * @param {Buffer|string} bufOrString
	 * @returns {boolean}
	 * @memberof Multibase
	 */
	function isEncoded (bufOrString) {
	  if (Buffer.isBuffer(bufOrString)) {
	    bufOrString = bufOrString.toString();
	  }

	  // Ensure bufOrString is a string
	  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
	    return false
	  }

	  const code = bufOrString.substring(0, 1);
	  try {
	    const base = getBase(code);
	    return base.name
	  } catch (err) {
	    return false
	  }
	}

	/**
	 * @param {string} name
	 * @param {Buffer} buf
	 * @private
	 * @returns {undefined}
	 */
	function validEncode (name, buf) {
	  const base = getBase(name);
	  base.decode(buf.toString());
	}

	function getBase (nameOrCode) {
	  let base;

	  if (constants_1$1.names[nameOrCode]) {
	    base = constants_1$1.names[nameOrCode];
	  } else if (constants_1$1.codes[nameOrCode]) {
	    base = constants_1$1.codes[nameOrCode];
	  } else {
	    throw errNotSupported
	  }

	  if (!base.isImplemented()) {
	    throw new Error('Base ' + nameOrCode + ' is not implemented yet')
	  }

	  return base
	}
	});

	var identity = 0;
	var ip4 = 4;
	var tcp = 6;
	var sha1 = 17;
	var blake3 = 30;
	var dccp = 33;
	var ip6 = 41;
	var ip6zone = 42;
	var path = 47;
	var multicodec = 48;
	var multihash = 49;
	var multiaddr = 50;
	var multibase = 51;
	var dns = 53;
	var dns4 = 54;
	var dns6 = 55;
	var dnsaddr = 56;
	var protobuf = 80;
	var cbor = 81;
	var raw = 85;
	var rlp = 96;
	var bencode = 99;
	var sctp = 132;
	var md4 = 212;
	var md5 = 213;
	var bmt = 214;
	var zeronet = 230;
	var udp = 273;
	var udt = 301;
	var utp = 302;
	var unix = 400;
	var p2p = 421;
	var ipfs = 421;
	var https = 443;
	var onion = 444;
	var onion3 = 445;
	var garlic64 = 446;
	var garlic32 = 447;
	var tls = 448;
	var quic = 460;
	var ws = 477;
	var wss = 478;
	var http = 480;
	var json = 512;
	var messagepack = 513;
	var x11 = 4352;
	var codecs = {
		identity: identity,
		ip4: ip4,
		tcp: tcp,
		sha1: sha1,
		"sha2-256": 18,
		"sha2-512": 19,
		"sha3-512": 20,
		"sha3-384": 21,
		"sha3-256": 22,
		"sha3-224": 23,
		"shake-128": 24,
		"shake-256": 25,
		"keccak-224": 26,
		"keccak-256": 27,
		"keccak-384": 28,
		"keccak-512": 29,
		blake3: blake3,
		dccp: dccp,
		"murmur3-128": 34,
		"murmur3-32": 35,
		ip6: ip6,
		ip6zone: ip6zone,
		path: path,
		multicodec: multicodec,
		multihash: multihash,
		multiaddr: multiaddr,
		multibase: multibase,
		dns: dns,
		dns4: dns4,
		dns6: dns6,
		dnsaddr: dnsaddr,
		protobuf: protobuf,
		cbor: cbor,
		raw: raw,
		"dbl-sha2-256": 86,
		rlp: rlp,
		bencode: bencode,
		"dag-pb": 112,
		"dag-cbor": 113,
		"libp2p-key": 114,
		"git-raw": 120,
		"torrent-info": 123,
		"torrent-file": 124,
		"leofcoin-block": 129,
		"leofcoin-tx": 130,
		"leofcoin-pr": 131,
		sctp: sctp,
		"dag-jose": 133,
		"dag-cose": 134,
		"eth-block": 144,
		"eth-block-list": 145,
		"eth-tx-trie": 146,
		"eth-tx": 147,
		"eth-tx-receipt-trie": 148,
		"eth-tx-receipt": 149,
		"eth-state-trie": 150,
		"eth-account-snapshot": 151,
		"eth-storage-trie": 152,
		"bitcoin-block": 176,
		"bitcoin-tx": 177,
		"bitcoin-witness-commitment": 178,
		"zcash-block": 192,
		"zcash-tx": 193,
		"stellar-block": 208,
		"stellar-tx": 209,
		md4: md4,
		md5: md5,
		bmt: bmt,
		"decred-block": 224,
		"decred-tx": 225,
		"ipld-ns": 226,
		"ipfs-ns": 227,
		"swarm-ns": 228,
		"ipns-ns": 229,
		zeronet: zeronet,
		"secp256k1-pub": 231,
		"bls12_381-g1-pub": 234,
		"bls12_381-g2-pub": 235,
		"x25519-pub": 236,
		"ed25519-pub": 237,
		"dash-block": 240,
		"dash-tx": 241,
		"swarm-manifest": 250,
		"swarm-feed": 251,
		udp: udp,
		"p2p-webrtc-star": 275,
		"p2p-webrtc-direct": 276,
		"p2p-stardust": 277,
		"p2p-circuit": 290,
		"dag-json": 297,
		udt: udt,
		utp: utp,
		unix: unix,
		p2p: p2p,
		ipfs: ipfs,
		https: https,
		onion: onion,
		onion3: onion3,
		garlic64: garlic64,
		garlic32: garlic32,
		tls: tls,
		quic: quic,
		ws: ws,
		wss: wss,
		"p2p-websocket-star": 479,
		http: http,
		json: json,
		messagepack: messagepack,
		"libp2p-peer-record": 769,
		"sha2-256-trunc254-padded": 4114,
		"ripemd-128": 4178,
		"ripemd-160": 4179,
		"ripemd-256": 4180,
		"ripemd-320": 4181,
		x11: x11,
		"sm3-256": 21325,
		"blake2b-8": 45569,
		"blake2b-16": 45570,
		"blake2b-24": 45571,
		"blake2b-32": 45572,
		"blake2b-40": 45573,
		"blake2b-48": 45574,
		"blake2b-56": 45575,
		"blake2b-64": 45576,
		"blake2b-72": 45577,
		"blake2b-80": 45578,
		"blake2b-88": 45579,
		"blake2b-96": 45580,
		"blake2b-104": 45581,
		"blake2b-112": 45582,
		"blake2b-120": 45583,
		"blake2b-128": 45584,
		"blake2b-136": 45585,
		"blake2b-144": 45586,
		"blake2b-152": 45587,
		"blake2b-160": 45588,
		"blake2b-168": 45589,
		"blake2b-176": 45590,
		"blake2b-184": 45591,
		"blake2b-192": 45592,
		"blake2b-200": 45593,
		"blake2b-208": 45594,
		"blake2b-216": 45595,
		"blake2b-224": 45596,
		"blake2b-232": 45597,
		"blake2b-240": 45598,
		"blake2b-248": 45599,
		"blake2b-256": 45600,
		"blake2b-264": 45601,
		"blake2b-272": 45602,
		"blake2b-280": 45603,
		"blake2b-288": 45604,
		"blake2b-296": 45605,
		"blake2b-304": 45606,
		"blake2b-312": 45607,
		"blake2b-320": 45608,
		"blake2b-328": 45609,
		"blake2b-336": 45610,
		"blake2b-344": 45611,
		"blake2b-352": 45612,
		"blake2b-360": 45613,
		"blake2b-368": 45614,
		"blake2b-376": 45615,
		"blake2b-384": 45616,
		"blake2b-392": 45617,
		"blake2b-400": 45618,
		"blake2b-408": 45619,
		"blake2b-416": 45620,
		"blake2b-424": 45621,
		"blake2b-432": 45622,
		"blake2b-440": 45623,
		"blake2b-448": 45624,
		"blake2b-456": 45625,
		"blake2b-464": 45626,
		"blake2b-472": 45627,
		"blake2b-480": 45628,
		"blake2b-488": 45629,
		"blake2b-496": 45630,
		"blake2b-504": 45631,
		"blake2b-512": 45632,
		"blake2s-8": 45633,
		"blake2s-16": 45634,
		"blake2s-24": 45635,
		"blake2s-32": 45636,
		"blake2s-40": 45637,
		"blake2s-48": 45638,
		"blake2s-56": 45639,
		"blake2s-64": 45640,
		"blake2s-72": 45641,
		"blake2s-80": 45642,
		"blake2s-88": 45643,
		"blake2s-96": 45644,
		"blake2s-104": 45645,
		"blake2s-112": 45646,
		"blake2s-120": 45647,
		"blake2s-128": 45648,
		"blake2s-136": 45649,
		"blake2s-144": 45650,
		"blake2s-152": 45651,
		"blake2s-160": 45652,
		"blake2s-168": 45653,
		"blake2s-176": 45654,
		"blake2s-184": 45655,
		"blake2s-192": 45656,
		"blake2s-200": 45657,
		"blake2s-208": 45658,
		"blake2s-216": 45659,
		"blake2s-224": 45660,
		"blake2s-232": 45661,
		"blake2s-240": 45662,
		"blake2s-248": 45663,
		"blake2s-256": 45664,
		"skein256-8": 45825,
		"skein256-16": 45826,
		"skein256-24": 45827,
		"skein256-32": 45828,
		"skein256-40": 45829,
		"skein256-48": 45830,
		"skein256-56": 45831,
		"skein256-64": 45832,
		"skein256-72": 45833,
		"skein256-80": 45834,
		"skein256-88": 45835,
		"skein256-96": 45836,
		"skein256-104": 45837,
		"skein256-112": 45838,
		"skein256-120": 45839,
		"skein256-128": 45840,
		"skein256-136": 45841,
		"skein256-144": 45842,
		"skein256-152": 45843,
		"skein256-160": 45844,
		"skein256-168": 45845,
		"skein256-176": 45846,
		"skein256-184": 45847,
		"skein256-192": 45848,
		"skein256-200": 45849,
		"skein256-208": 45850,
		"skein256-216": 45851,
		"skein256-224": 45852,
		"skein256-232": 45853,
		"skein256-240": 45854,
		"skein256-248": 45855,
		"skein256-256": 45856,
		"skein512-8": 45857,
		"skein512-16": 45858,
		"skein512-24": 45859,
		"skein512-32": 45860,
		"skein512-40": 45861,
		"skein512-48": 45862,
		"skein512-56": 45863,
		"skein512-64": 45864,
		"skein512-72": 45865,
		"skein512-80": 45866,
		"skein512-88": 45867,
		"skein512-96": 45868,
		"skein512-104": 45869,
		"skein512-112": 45870,
		"skein512-120": 45871,
		"skein512-128": 45872,
		"skein512-136": 45873,
		"skein512-144": 45874,
		"skein512-152": 45875,
		"skein512-160": 45876,
		"skein512-168": 45877,
		"skein512-176": 45878,
		"skein512-184": 45879,
		"skein512-192": 45880,
		"skein512-200": 45881,
		"skein512-208": 45882,
		"skein512-216": 45883,
		"skein512-224": 45884,
		"skein512-232": 45885,
		"skein512-240": 45886,
		"skein512-248": 45887,
		"skein512-256": 45888,
		"skein512-264": 45889,
		"skein512-272": 45890,
		"skein512-280": 45891,
		"skein512-288": 45892,
		"skein512-296": 45893,
		"skein512-304": 45894,
		"skein512-312": 45895,
		"skein512-320": 45896,
		"skein512-328": 45897,
		"skein512-336": 45898,
		"skein512-344": 45899,
		"skein512-352": 45900,
		"skein512-360": 45901,
		"skein512-368": 45902,
		"skein512-376": 45903,
		"skein512-384": 45904,
		"skein512-392": 45905,
		"skein512-400": 45906,
		"skein512-408": 45907,
		"skein512-416": 45908,
		"skein512-424": 45909,
		"skein512-432": 45910,
		"skein512-440": 45911,
		"skein512-448": 45912,
		"skein512-456": 45913,
		"skein512-464": 45914,
		"skein512-472": 45915,
		"skein512-480": 45916,
		"skein512-488": 45917,
		"skein512-496": 45918,
		"skein512-504": 45919,
		"skein512-512": 45920,
		"skein1024-8": 45921,
		"skein1024-16": 45922,
		"skein1024-24": 45923,
		"skein1024-32": 45924,
		"skein1024-40": 45925,
		"skein1024-48": 45926,
		"skein1024-56": 45927,
		"skein1024-64": 45928,
		"skein1024-72": 45929,
		"skein1024-80": 45930,
		"skein1024-88": 45931,
		"skein1024-96": 45932,
		"skein1024-104": 45933,
		"skein1024-112": 45934,
		"skein1024-120": 45935,
		"skein1024-128": 45936,
		"skein1024-136": 45937,
		"skein1024-144": 45938,
		"skein1024-152": 45939,
		"skein1024-160": 45940,
		"skein1024-168": 45941,
		"skein1024-176": 45942,
		"skein1024-184": 45943,
		"skein1024-192": 45944,
		"skein1024-200": 45945,
		"skein1024-208": 45946,
		"skein1024-216": 45947,
		"skein1024-224": 45948,
		"skein1024-232": 45949,
		"skein1024-240": 45950,
		"skein1024-248": 45951,
		"skein1024-256": 45952,
		"skein1024-264": 45953,
		"skein1024-272": 45954,
		"skein1024-280": 45955,
		"skein1024-288": 45956,
		"skein1024-296": 45957,
		"skein1024-304": 45958,
		"skein1024-312": 45959,
		"skein1024-320": 45960,
		"skein1024-328": 45961,
		"skein1024-336": 45962,
		"skein1024-344": 45963,
		"skein1024-352": 45964,
		"skein1024-360": 45965,
		"skein1024-368": 45966,
		"skein1024-376": 45967,
		"skein1024-384": 45968,
		"skein1024-392": 45969,
		"skein1024-400": 45970,
		"skein1024-408": 45971,
		"skein1024-416": 45972,
		"skein1024-424": 45973,
		"skein1024-432": 45974,
		"skein1024-440": 45975,
		"skein1024-448": 45976,
		"skein1024-456": 45977,
		"skein1024-464": 45978,
		"skein1024-472": 45979,
		"skein1024-480": 45980,
		"skein1024-488": 45981,
		"skein1024-496": 45982,
		"skein1024-504": 45983,
		"skein1024-512": 45984,
		"skein1024-520": 45985,
		"skein1024-528": 45986,
		"skein1024-536": 45987,
		"skein1024-544": 45988,
		"skein1024-552": 45989,
		"skein1024-560": 45990,
		"skein1024-568": 45991,
		"skein1024-576": 45992,
		"skein1024-584": 45993,
		"skein1024-592": 45994,
		"skein1024-600": 45995,
		"skein1024-608": 45996,
		"skein1024-616": 45997,
		"skein1024-624": 45998,
		"skein1024-632": 45999,
		"skein1024-640": 46000,
		"skein1024-648": 46001,
		"skein1024-656": 46002,
		"skein1024-664": 46003,
		"skein1024-672": 46004,
		"skein1024-680": 46005,
		"skein1024-688": 46006,
		"skein1024-696": 46007,
		"skein1024-704": 46008,
		"skein1024-712": 46009,
		"skein1024-720": 46010,
		"skein1024-728": 46011,
		"skein1024-736": 46012,
		"skein1024-744": 46013,
		"skein1024-752": 46014,
		"skein1024-760": 46015,
		"skein1024-768": 46016,
		"skein1024-776": 46017,
		"skein1024-784": 46018,
		"skein1024-792": 46019,
		"skein1024-800": 46020,
		"skein1024-808": 46021,
		"skein1024-816": 46022,
		"skein1024-824": 46023,
		"skein1024-832": 46024,
		"skein1024-840": 46025,
		"skein1024-848": 46026,
		"skein1024-856": 46027,
		"skein1024-864": 46028,
		"skein1024-872": 46029,
		"skein1024-880": 46030,
		"skein1024-888": 46031,
		"skein1024-896": 46032,
		"skein1024-904": 46033,
		"skein1024-912": 46034,
		"skein1024-920": 46035,
		"skein1024-928": 46036,
		"skein1024-936": 46037,
		"skein1024-944": 46038,
		"skein1024-952": 46039,
		"skein1024-960": 46040,
		"skein1024-968": 46041,
		"skein1024-976": 46042,
		"skein1024-984": 46043,
		"skein1024-992": 46044,
		"skein1024-1000": 46045,
		"skein1024-1008": 46046,
		"skein1024-1016": 46047,
		"skein1024-1024": 46048,
		"poseidon-bls12_381-a2-fc1": 46081,
		"poseidon-bls12_381-a2-fc1-sc": 46082,
		"zeroxcert-imprint-256": 52753,
		"fil-commitment-unsealed": 61697,
		"fil-commitment-sealed": 61698,
		"holochain-adr-v0": 8417572,
		"holochain-adr-v1": 8483108,
		"holochain-key-v0": 9728292,
		"holochain-key-v1": 9793828,
		"holochain-sig-v0": 10645796,
		"holochain-sig-v1": 10711332
	};

	// map for hexString -> codecName
	const nameTable = new Map();

	for (const encodingName in codecs) {
	  const code = codecs[encodingName];
	  nameTable.set(code, encodingName);
	}

	var intTable = Object.freeze(nameTable);

	const { Buffer: Buffer$3 } = require$$0;

	var util = {
	  numberToBuffer,
	  bufferToNumber,
	  varintBufferEncode,
	  varintBufferDecode,
	  varintEncode: varintEncode$1
	};

	function bufferToNumber (buf) {
	  return parseInt(buf.toString('hex'), 16)
	}

	function numberToBuffer (num) {
	  let hexString = num.toString(16);
	  if (hexString.length % 2 === 1) {
	    hexString = '0' + hexString;
	  }
	  return Buffer$3.from(hexString, 'hex')
	}

	function varintBufferEncode (input) {
	  return Buffer$3.from(varint.encode(bufferToNumber(input)))
	}

	function varintBufferDecode (input) {
	  return numberToBuffer(varint.decode(input))
	}

	function varintEncode$1 (num) {
	  return Buffer$3.from(varint.encode(num))
	}

	const varintEncode = util.varintEncode;

	// map for codecName -> codeVarintBuffer
	const varintTable = {};

	for (const encodingName in codecs) {
	  const code = codecs[encodingName];
	  varintTable[encodingName] = varintEncode(code);
	}

	var varintTable_1 = Object.freeze(varintTable);

	// map for codecConstant -> code
	const constants = {};

	for (const [name, code] of Object.entries(codecs)) {
	  constants[name.toUpperCase().replace(/-/g, '_')] = code;
	}

	var constants_1 = Object.freeze(constants);

	// map for code -> print friendly name
	const tableByCode = {};

	for (const [name, code] of Object.entries(codecs)) {
	  if (tableByCode[code] === undefined) tableByCode[code] = name;
	}

	var print = Object.freeze(tableByCode);

	/**
	 * Implementation of the multicodec specification.
	 *
	 * @module multicodec
	 * @example
	 * const multicodec = require('multicodec')
	 *
	 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
	 * // prefixedProtobuf 0x50...
	 *
	 */

	var src$2 = createCommonjsModule(function (module, exports) {

	const { Buffer } = require$$0;





	exports = module.exports;

	/**
	 * Prefix a buffer with a multicodec-packed.
	 *
	 * @param {string|number} multicodecStrOrCode
	 * @param {Buffer} data
	 * @returns {Buffer}
	 */
	exports.addPrefix = (multicodecStrOrCode, data) => {
	  let prefix;

	  if (Buffer.isBuffer(multicodecStrOrCode)) {
	    prefix = util.varintBufferEncode(multicodecStrOrCode);
	  } else {
	    if (varintTable_1[multicodecStrOrCode]) {
	      prefix = varintTable_1[multicodecStrOrCode];
	    } else {
	      throw new Error('multicodec not recognized')
	    }
	  }
	  return Buffer.concat([prefix, data])
	};

	/**
	 * Decapsulate the multicodec-packed prefix from the data.
	 *
	 * @param {Buffer} data
	 * @returns {Buffer}
	 */
	exports.rmPrefix = (data) => {
	  varint.decode(data);
	  return data.slice(varint.decode.bytes)
	};

	/**
	 * Get the codec of the prefixed data.
	 * @param {Buffer} prefixedData
	 * @returns {string}
	 */
	exports.getCodec = (prefixedData) => {
	  const code = varint.decode(prefixedData);
	  const codecName = intTable.get(code);
	  if (codecName === undefined) {
	    throw new Error(`Code ${code} not found`)
	  }
	  return codecName
	};

	/**
	 * Get the name of the codec.
	 * @param {number} codec
	 * @returns {string}
	 */
	exports.getName = (codec) => {
	  return intTable.get(codec)
	};

	/**
	 * Get the code of the codec
	 * @param {string} name
	 * @returns {number}
	 */
	exports.getNumber = (name) => {
	  const code = varintTable_1[name];
	  if (code === undefined) {
	    throw new Error('Codec `' + name + '` not found')
	  }
	  return util.varintBufferDecode(code)[0]
	};

	/**
	 * Get the code of the prefixed data.
	 * @param {Buffer} prefixedData
	 * @returns {number}
	 */
	exports.getCode = (prefixedData) => {
	  return varint.decode(prefixedData)
	};

	/**
	 * Get the code as varint of a codec name.
	 * @param {string} codecName
	 * @returns {Buffer}
	 */
	exports.getCodeVarint = (codecName) => {
	  const code = varintTable_1[codecName];
	  if (code === undefined) {
	    throw new Error('Codec `' + codecName + '` not found')
	  }
	  return code
	};

	/**
	 * Get the varint of a code.
	 * @param {Number} code
	 * @returns {Array.<number>}
	 */
	exports.getVarint = (code) => {
	  return varint.encode(code)
	};

	// Make the constants top-level constants

	Object.assign(exports, constants_1);

	// Human friendly names for printing, e.g. in error messages
	exports.print = print;
	});

	const { Buffer: Buffer$2 } = require$$0;
	var CIDUtil = {
	  /**
	   * Test if the given input is a valid CID object.
	   * Returns an error message if it is not.
	   * Returns undefined if it is a valid CID.
	   *
	   * @param {any} other
	   * @returns {string}
	   */
	  checkCIDComponents: function (other) {
	    if (other == null) {
	      return 'null values are not valid CIDs'
	    }

	    if (!(other.version === 0 || other.version === 1)) {
	      return 'Invalid version, must be a number equal to 1 or 0'
	    }

	    if (typeof other.codec !== 'string') {
	      return 'codec must be string'
	    }

	    if (other.version === 0) {
	      if (other.codec !== 'dag-pb') {
	        return "codec must be 'dag-pb' for CIDv0"
	      }
	      if (other.multibaseName !== 'base58btc') {
	        return "multibaseName must be 'base58btc' for CIDv0"
	      }
	    }

	    if (!Buffer$2.isBuffer(other.multihash)) {
	      return 'multihash must be a Buffer'
	    }

	    try {
	      src$4.validate(other.multihash);
	    } catch (err) {
	      let errorMsg = err.message;
	      if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
	        errorMsg = 'Multihash validation failed';
	      }
	      return errorMsg
	    }
	  }
	};

	var cidUtil = CIDUtil;

	function withIs(Class, { className, symbolName }) {
	    const symbol = Symbol.for(symbolName);

	    const ClassIsWrapper = {
	        // The code below assigns the class wrapper to an object to trick
	        // JavaScript engines to show the name of the extended class when
	        // logging an instances.
	        // We are assigning an anonymous class (class wrapper) to the object
	        // with key `className` to keep the correct name.
	        // If this is not supported it falls back to logging `ClassIsWrapper`.
	        [className]: class extends Class {
	            constructor(...args) {
	                super(...args);
	                Object.defineProperty(this, symbol, { value: true });
	            }

	            get [Symbol.toStringTag]() {
	                return className;
	            }
	        },
	    }[className];

	    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

	    return ClassIsWrapper;
	}

	function withIsProto(Class, { className, symbolName, withoutNew }) {
	    const symbol = Symbol.for(symbolName);

	    /* eslint-disable object-shorthand */
	    const ClassIsWrapper = {
	        [className]: function (...args) {
	            if (withoutNew && !(this instanceof ClassIsWrapper)) {
	                return new ClassIsWrapper(...args);
	            }

	            const _this = Class.call(this, ...args) || this;

	            if (_this && !_this[symbol]) {
	                Object.defineProperty(_this, symbol, { value: true });
	            }

	            return _this;
	        },
	    }[className];
	    /* eslint-enable object-shorthand */

	    ClassIsWrapper.prototype = Object.create(Class.prototype);
	    ClassIsWrapper.prototype.constructor = ClassIsWrapper;

	    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
	        get() {
	            return className;
	        },
	    });

	    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);

	    return ClassIsWrapper;
	}

	var classIs = withIs;
	var proto = withIsProto;
	classIs.proto = proto;

	const { Buffer: Buffer$1 } = require$$0;







	/**
	 * @typedef {Object} SerializedCID
	 * @param {string} codec
	 * @param {number} version
	 * @param {Buffer} multihash
	 */

	/**
	 * Test if the given input is a CID.
	 * @function isCID
	 * @memberof CID
	 * @static
	 * @param {any} other
	 * @returns {bool}
	 */

	/**
	 * Class representing a CID `<mbase><version><mcodec><mhash>`
	 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
	 * @class CID
	 */
	class CID {
	  /**
	   * Create a new CID.
	   *
	   * The algorithm for argument input is roughly:
	   * ```
	   * if (cid)
	   *   -> create a copy
	   * else if (str)
	   *   if (1st char is on multibase table) -> CID String
	   *   else -> bs58 encoded multihash
	   * else if (Buffer)
	   *   if (1st byte is 0 or 1) -> CID
	   *   else -> multihash
	   * else if (Number)
	   *   -> construct CID by parts
	   * ```
	   *
	   * @param {string|Buffer|CID} version
	   * @param {string} [codec]
	   * @param {Buffer} [multihash]
	   * @param {string} [multibaseName]
	   *
	   * @example
	   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
	   * new CID(<cidStr>)
	   * new CID(<cid.buffer>)
	   * new CID(<multihash>)
	   * new CID(<bs58 encoded multihash>)
	   * new CID(<cid>)
	   */
	  constructor (version, codec, multihash, multibaseName) {
	    if (_CID.isCID(version)) {
	      // version is an exising CID instance
	      const cid = version;
	      this.version = cid.version;
	      this.codec = cid.codec;
	      this.multihash = Buffer$1.from(cid.multihash);
	      // Default guard for when a CID < 0.7 is passed with no multibaseName
	      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');
	      return
	    }

	    if (typeof version === 'string') {
	      // e.g. 'base32' or false
	      const baseName = src$3.isEncoded(version);
	      if (baseName) {
	        // version is a CID String encoded with multibase, so v1
	        const cid = src$3.decode(version);
	        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16);
	        this.codec = src$2.getCodec(cid.slice(1));
	        this.multihash = src$2.rmPrefix(cid.slice(1));
	        this.multibaseName = baseName;
	      } else {
	        // version is a base58btc string multihash, so v0
	        this.version = 0;
	        this.codec = 'dag-pb';
	        this.multihash = src$4.fromB58String(version);
	        this.multibaseName = 'base58btc';
	      }
	      CID.validateCID(this);
	      Object.defineProperty(this, 'string', { value: version });
	      return
	    }

	    if (Buffer$1.isBuffer(version)) {
	      const firstByte = version.slice(0, 1);
	      const v = parseInt(firstByte.toString('hex'), 16);
	      if (v === 1) {
	        // version is a CID buffer
	        const cid = version;
	        this.version = v;
	        this.codec = src$2.getCodec(cid.slice(1));
	        this.multihash = src$2.rmPrefix(cid.slice(1));
	        this.multibaseName = 'base32';
	      } else {
	        // version is a raw multihash buffer, so v0
	        this.version = 0;
	        this.codec = 'dag-pb';
	        this.multihash = version;
	        this.multibaseName = 'base58btc';
	      }
	      CID.validateCID(this);
	      return
	    }

	    // otherwise, assemble the CID from the parameters

	    /**
	     * @type {number}
	     */
	    this.version = version;

	    /**
	     * @type {string}
	     */
	    this.codec = codec;

	    /**
	     * @type {Buffer}
	     */
	    this.multihash = multihash;

	    /**
	     * @type {string}
	     */
	    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');

	    CID.validateCID(this);
	  }

	  /**
	   * The CID as a `Buffer`
	   *
	   * @return {Buffer}
	   * @readonly
	   *
	   * @memberOf CID
	   */
	  get buffer () {
	    let buffer = this._buffer;

	    if (!buffer) {
	      if (this.version === 0) {
	        buffer = this.multihash;
	      } else if (this.version === 1) {
	        buffer = Buffer$1.concat([
	          Buffer$1.from('01', 'hex'),
	          src$2.getCodeVarint(this.codec),
	          this.multihash
	        ]);
	      } else {
	        throw new Error('unsupported version')
	      }

	      // Cache this buffer so it doesn't have to be recreated
	      Object.defineProperty(this, '_buffer', { value: buffer });
	    }

	    return buffer
	  }

	  /**
	   * Get the prefix of the CID.
	   *
	   * @returns {Buffer}
	   * @readonly
	   */
	  get prefix () {
	    return Buffer$1.concat([
	      Buffer$1.from(`0${this.version}`, 'hex'),
	      src$2.getCodeVarint(this.codec),
	      src$4.prefix(this.multihash)
	    ])
	  }

	  /**
	   * Convert to a CID of version `0`.
	   *
	   * @returns {CID}
	   */
	  toV0 () {
	    if (this.codec !== 'dag-pb') {
	      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
	    }

	    const { name, length } = src$4.decode(this.multihash);

	    if (name !== 'sha2-256') {
	      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
	    }

	    if (length !== 32) {
	      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
	    }

	    return new _CID(0, this.codec, this.multihash)
	  }

	  /**
	   * Convert to a CID of version `1`.
	   *
	   * @returns {CID}
	   */
	  toV1 () {
	    return new _CID(1, this.codec, this.multihash)
	  }

	  /**
	   * Encode the CID into a string.
	   *
	   * @param {string} [base=this.multibaseName] - Base encoding to use.
	   * @returns {string}
	   */
	  toBaseEncodedString (base = this.multibaseName) {
	    if (this.string && base === this.multibaseName) {
	      return this.string
	    }
	    let str = null;
	    if (this.version === 0) {
	      if (base !== 'base58btc') {
	        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
	      }
	      str = src$4.toB58String(this.multihash);
	    } else if (this.version === 1) {
	      str = src$3.encode(base, this.buffer).toString();
	    } else {
	      throw new Error('unsupported version')
	    }
	    if (base === this.multibaseName) {
	      // cache the string value
	      Object.defineProperty(this, 'string', { value: str });
	    }
	    return str
	  }

	  /**
	   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
	   *
	   * @returns {String}
	   */
	  [Symbol.for('nodejs.util.inspect.custom')] () {
	    return 'CID(' + this.toString() + ')'
	  }

	  toString (base) {
	    return this.toBaseEncodedString(base)
	  }

	  /**
	   * Serialize to a plain object.
	   *
	   * @returns {SerializedCID}
	   */
	  toJSON () {
	    return {
	      codec: this.codec,
	      version: this.version,
	      hash: this.multihash
	    }
	  }

	  /**
	   * Compare equality with another CID.
	   *
	   * @param {CID} other
	   * @returns {bool}
	   */
	  equals (other) {
	    return this.codec === other.codec &&
	      this.version === other.version &&
	      this.multihash.equals(other.multihash)
	  }

	  /**
	   * Test if the given input is a valid CID object.
	   * Throws if it is not.
	   *
	   * @param {any} other
	   * @returns {void}
	   */
	  static validateCID (other) {
	    const errorMsg = cidUtil.checkCIDComponents(other);
	    if (errorMsg) {
	      throw new Error(errorMsg)
	    }
	  }
	}

	const _CID = classIs(CID, {
	  className: 'CID',
	  symbolName: '@ipld/js-cid/CID'
	});

	_CID.codecs = codecs;

	var src$1 = _CID;

	/*
		ISC License

		Copyright (c) 2019, Pierre-Louis Despaigne

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted, provided that the above
		copyright notice and this permission notice appear in all copies.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
		WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
		MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
		ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
		WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
		ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
		OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	*/

	/**
	 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
	 * @param {string} hex an hexadecimal value
	 * @return {Buffer} the resulting Buffer
	 */
	const hexStringToBuffer$1 = (hex) => {
		let prefix = hex.slice(0, 2);
		let value = hex.slice(2);
		let res = '';
		if (prefix === '0x') res = value;
		else res = hex;
		return src$4.fromHexString(res);
	};

	/**
	* list of known encoding,
	* encoding should be a function that takes a `string` input,
	* and return a `Buffer` result
	*/
	const encodes = {
	  /**
	  * @param {string} value
	  * @return {Buffer}
	  */
	  swarm: (value) => {
	    const multihash = src$4.encode(hexStringToBuffer$1(value), 'keccak-256');
			return new src$1(1, 'swarm-manifest', multihash).buffer;
	  },
	  /**
	  * @param {string} value
	  * @return {Buffer}
	  */
	  ipfs: (value) => {
	    const multihash = src$4.fromB58String(value);
	    return new src$1(1, 'dag-pb', multihash).buffer;
	  },
	  /**
	  * @param {string} value
	  * @return {Buffer}
	  */
	  utf8: (value) => {
	    return Buffer.from(value, 'utf8');
	  },
	};

	/** 
	* list of known decoding,
	* decoding should be a function that takes a `Buffer` input,
	* and return a `string` result
	*/
	const decodes = {
	  /**
	  * @param {Buffer} value 
	  */
	  hexMultiHash: (value) => {
	    const cid = new src$1(value);
	    return src$4.decode(cid.multihash).digest.toString('hex');
	  },
	  /**
	  * @param {Buffer} value 
	  */
	  b58MultiHash: (value) => {
	    const cid = new src$1(value);
	    return src$4.toB58String(cid.multihash);
	  },
	  /**
	  * @param {Buffer} value 
	  */
	  utf8: (value) => {
	    return value.toString('utf8');
	  },
	};

	/**
	* list of known encoding/decoding for a given codec,
	* `encode` should be chosen among the `encodes` functions
	* `decode` should be chosen among the `decodes` functions
	*/
	const profiles$1 = {
	  'swarm-ns': {
	    encode: encodes.swarm,
	    decode: decodes.hexMultiHash,
	  },
	  'ipfs-ns': {
	    encode: encodes.ipfs,
	    decode: decodes.b58MultiHash,
	  },
	  'ipns-ns': {
	    encode: encodes.ipfs,
	    decode: decodes.b58MultiHash,
	  },
	  'default': {
	    encode: encodes.utf8,
	    decode: decodes.utf8,
	  },
	};

	var hexStringToBuffer_1 = hexStringToBuffer$1;
	var profiles_2 = profiles$1;

	var profiles_1 = {
		hexStringToBuffer: hexStringToBuffer_1,
		profiles: profiles_2
	};

	/*
		ISC License

		Copyright (c) 2019, Pierre-Louis Despaigne

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted, provided that the above
		copyright notice and this permission notice appear in all copies.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
		WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
		MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
		ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
		WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
		ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
		OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	*/

	/**
	 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
	 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
	 * @return {string} the resulting ipfs hash as a cid v1
	 */
	const cidV0ToV1Base32$1 = (ipfsHash) => {
		let cid = new src$1(ipfsHash);
		if (cid.version === 0) {
			cid = cid.toV1();
		}
		return cid.toString('base32');
	};

	var cidV0ToV1Base32_1 = cidV0ToV1Base32$1;

	var helpers = {
		cidV0ToV1Base32: cidV0ToV1Base32_1
	};

	/*
		ISC License

		Copyright (c) 2019, Pierre-Louis Despaigne

		Permission to use, copy, modify, and/or distribute this software for any
		purpose with or without fee is hereby granted, provided that the above
		copyright notice and this permission notice appear in all copies.

		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
		WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
		MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
		ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
		WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
		ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
		OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	*/

	const { hexStringToBuffer, profiles } = profiles_1;
	const { cidV0ToV1Base32 } = helpers;

	var src = {

		//export some helpers functions
		helpers: {
			cidV0ToV1Base32,
		},

		/**
		* Decode a Content Hash.
		* @param {string} hash an hex string containing a content hash
		* @return {string} the decoded content
		*/
		decode: function (contentHash) {
			const buffer = hexStringToBuffer(contentHash);
			const codec = src$7.getCodec(buffer);
			const value = src$7.rmPrefix(buffer);
			let profile = profiles[codec];
			if (!profile) profile = profiles['default'];
			return profile.decode(value);
		},

		/**
		* Encode an IPFS address into a content hash
		* @param {string} ipfsHash string containing an IPFS address
		* @return {string} the resulting content hash
		*/
		fromIpfs: function (ipfsHash) {
			return this.encode('ipfs-ns', ipfsHash);
		},

		/**
		* Encode a Swarm address into a content hash
		* @param {string} swarmHash string containing a Swarm address
		* @return {string} the resulting content hash
		*/
		fromSwarm: function (swarmHash) {
			return this.encode('swarm-ns', swarmHash);
		},

		/**
		* General purpose encoding function
	  * @param {string} codec 
	  * @param {string} value 
	  */
		encode: function (codec, value) {
			let profile = profiles[codec];
			if (!profile) profile = profiles['default'];
			const encodedValue = profile.encode(value);
			return src$7.addPrefix(codec, encodedValue).toString('hex');
		},

		/**
		* Extract the codec of a content hash
		* @param {string} hash hex string containing a content hash
		* @return {string} the extracted codec
		*/
		getCodec: function (hash) {
			let buffer = hexStringToBuffer(hash);
			return src$7.getCodec(buffer);
		},
	};

	var fs = /*@__PURE__*/getAugmentedNamespace(empty$1);

	function generatorKey() {
	  var es = src.encode("swarm-ns", fs.readFileSync("../../../package.json"));
	  Buffer.from(es.substring(0, 16), 'utf8');
	  Buffer.from(es.substring(2, 18), 'utf8');
	}

	generatorKey(); // const sign = encrypt('hello world');

})));
